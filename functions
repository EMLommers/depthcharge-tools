#!/bin/sh

# ChromeOS firmware injects one of these values into the cmdline based
# on which boot mechanism is used. A 'secure' argument allows us to
# select for devices where a cros partition is absolutely necessary.
is_cros_machine() {
    case "$(cat /proc/cmdline)" in
        *cros_secure*)
            return 0
            ;;
        *cros_efi*|*cros_legacy*)
            [ "$1" = "secure" ] && return 1
            return 0
            ;;
    esac
    return 1
}

# This function takes some devices (e.g. /dev/sda, /dev/mapper/luks-*,
# /dev/dm-0, /dev/disk/by-partuuid/*), tries to find physical disks
# where they are on.
find_disks() {
    # Use real devices for all. Turns /dev/disk/** into /dev/*.
    for d in "$@"; do
        set -- "$@" "$(readlink -f "$1")"
        shift
    done

    # We can have chains of VG-LV, dm-*, md*, *_crypt, so on. They can
    # resolve to multiple devices. So we keep a stack of devices to
    # search (in $@) and prepend new ones to run in the next cycle of
    # the loop. We also need to keep the results in a stack, so keep
    # them at the end divided with a separator.
    BREAK="{BREAK}"
    set -- "$@" "$BREAK"
    while [ "$#" -gt 0 ]; do
        if [ "$1" = "$BREAK" ]; then
            shift
            break
        else
            dev="$(basename "$1")"
            shift
        fi

        parent="$(readlink -f "/sys/class/block/${dev}/..")" || parent=''
        case "$parent" in
            # VG-LV, sda2_crypt e.g. doesn't exist in /sys/class/block,
            # so readlink fails. We check each dm device's name here to
            # find which dm-* device they actually are.
            '')
                for d in /sys/class/block/dm-*; do
                    d="$(basename "$d")"
                    if grep -qs "$dev" "/sys/class/block/${d}/dm/name"; then
                        set -- "$d" "$@"
                    fi
                done
                ;;
            # dm-* and md* reside on /sys/devices/virtual/block, and
            # have a "slaves" folder for partitions they are built on.
            */virtual/block)
                for d in "/sys/class/block/${dev}/slaves"/*; do
                    set -- "$(basename "$d")" "$@"
                done
                ;;
            # Real partitions e.g. /sys/devices/**/block/sda/sda2
            # but we need their parent, sda.
            */block/*)
                set -- "$(basename "$parent")" "$@"
                ;;
            # These are real disks we can use. Keep them after the
            # separator, without duplicates.
            */block)
                case "$@" in
                    *${BREAK}*${dev}*) continue ;;
                esac
                if [ -b "/dev/${dev}" ]; then
                    set -- "$@" "$dev"
                fi
                ;;
            # I don't know what goes here, but let's try the parent.
            *)
                set -- "$(basename "$parent")" "$@"
                ;;
        esac
    done

    echo "$@"
}

# Get a partition device from disk device and partition number.
dev_from_disk_part() {
    case "$1" in
        # mmcblk0 1 -> mmcblk0p1
        # nvme0n1 2 -> nvme0n1p2
        *[0-9]) echo "${1}p${2}" ;;
        # sda 3 -> sda3
        *) echo "${1}${2}" ;;
    esac
}

# Get comma seperated disk device and partition number from a device.
disk_part_from_dev() {
    case "$1" in
        # Don't consider mmcblk1rpmb, mmcblk1boot0 as partitions.
        *boot*|*rpmb*) echo "${1}," ;;
        # mmcblk0p1 -> mmcblk0,1
        # nvme0n1p2 -> nvme0n1,2
        *[0-9]p[0-9]*) echo "${1%p*},${1##*p}" ;;
        # sda1 -> sda,1
        *[0-9]) echo "${1%%[0-9]*},${1##*[!0-9]}" ;;
        *) echo "${1}," ;;
    esac
}

# Find the lowest-priority ChromeOS kernel partition across given disks.
find_depthcharge_part() {
    # Max priority is 15; use 99 to indicate no valid partition.
    best_prio=99
    best_part=""
    prio=99

    for disk in "$@"; do
        for partno in $(cgpt find -n -t kernel "$disk"); do
            prio="$(cgpt show -i "$partno" -P "$disk")" || prio=99
            if [ "$prio" -lt "$best_prio" ]; then
                best_prio="$prio"
                best_part="$(dev_from_disk_part "$disk" "$partno")"
            fi
        done
    done

    if [ -n "$best_part" ]; then
        echo "$best_part"
    else
        return 1
    fi
}
