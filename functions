#!/bin/sh

. "lib/msg.sh"

# ChromeOS firmware injects one of these values into the cmdline based
# on which boot mechanism is used. A 'secure' argument allows us to
# select for devices where a cros partition is absolutely necessary.
is_cros_machine() {
    case "$(cat /proc/cmdline)" in
        *cros_secure*)
            return 0
            ;;
        *cros_efi*|*cros_legacy*)
            [ "$1" = "secure" ] && return 1
            return 0
            ;;
    esac
    return 1
}

# This function takes some devices (e.g. /dev/sda, /dev/mapper/luks-*,
# /dev/dm-0, /dev/disk/by-partuuid/*), tries to find physical disks
# where they are on.
find_disks() {
    # Use real devices for all. Turns /dev/disk/** into /dev/*.
    for d in "$@"; do
        if [ -n "$d" ]; then
            set -- "$@" "$(readlink -f "$d")"
        fi
        shift
    done

    # We can have chains of VG-LV, dm-*, md*, *_crypt, so on. They can
    # resolve to multiple devices. So we keep a stack of devices to
    # search (in $@) and prepend new ones to run in the next cycle of
    # the loop. We also need to keep the results in a stack, so keep
    # them at the end divided with a separator.
    BREAK="{BREAK}"
    set -- "$@" "$BREAK"
    while [ "$#" -gt 0 ]; do
        if [ "$1" = "$BREAK" ]; then
            shift
            break
        else
            dev="$(basename "$1")"
            shift
        fi

        parent="$(readlink -f "/sys/class/block/${dev}/..")" || parent=''
        case "$parent" in
            # VG-LV, sda2_crypt e.g. doesn't exist in /sys/class/block,
            # so readlink fails. We check each dm device's name here to
            # find which dm-* device they actually are.
            '')
                for d in /sys/class/block/dm-*; do
                    d="$(basename "$d")"
                    if grep -qs "$dev" "/sys/class/block/${d}/dm/name"; then
                        set -- "$d" "$@"
                    fi
                done
                ;;
            # dm-* and md* reside on /sys/devices/virtual/block, and
            # have a "slaves" folder for partitions they are built on.
            */virtual/block)
                for d in "/sys/class/block/${dev}/slaves"/*; do
                    set -- "$(basename "$d")" "$@"
                done
                ;;
            # Real partitions e.g. /sys/devices/**/block/sda/sda2
            # but we need their parent, sda.
            */block/*)
                set -- "$(basename "$parent")" "$@"
                ;;
            # These are real disks we can use. Keep them after the
            # separator, without duplicates.
            */block)
                case "$@" in
                    *${BREAK}*${dev}*) continue ;;
                esac
                if [ -b "/dev/${dev}" ]; then
                    set -- "$@" "/dev/${dev}"
                fi
                ;;
            # I don't know what goes here, but let's try the parent.
            *)
                set -- "$(basename "$parent")" "$@"
                ;;
        esac
    done

    echo "$@"
}

# Get a partition device from disk device and partition number.
dev_from_disk_part() {
    case "$1" in
        # mmcblk0 1 -> mmcblk0p1
        # nvme0n1 2 -> nvme0n1p2
        *[0-9]) echo "${1}p${2}" ;;
        # sda 3 -> sda3
        *) echo "${1}${2}" ;;
    esac
}

# Get comma seperated disk device and partition number from a device.
disk_part_from_dev() {
    case "$1" in
        # Don't consider mmcblk1rpmb, mmcblk1boot0 as partitions.
        *boot*|*rpmb*) echo "${1}," ;;
        # mmcblk0p1 -> mmcblk0,1
        # nvme0n1p2 -> nvme0n1,2
        *[0-9]p[0-9]*) echo "${1%p*},${1##*p}" ;;
        # sda1 -> sda,1
        *[0-9]) echo "${1%%[0-9]*},${1##*[!0-9]}" ;;
        *) echo "${1}," ;;
    esac
}

# Find the lowest-priority ChromeOS kernel partition across given disks.
find_depthcharge_part() {
    # Max priority is 15; use 99 to indicate no valid partition.
    best_prio=99
    best_part=""
    prio=99

    for disk in "$@"; do
        for partno in $(cgpt find -n -t kernel "$disk"); do
            prio="$(cgpt show -i "$partno" -P "$disk")" || prio=99
            if [ "$prio" -lt "$best_prio" ]; then
                best_prio="$prio"
                best_part="$(dev_from_disk_part "$disk" "$partno")"
            fi
        done
    done

    if [ -n "$best_part" ]; then
        echo "$best_part"
    else
        return 1
    fi
}

# Finds values for a key, among input lines of "<key>: <values>".
parse_config() {
    field="$1"
    set --

    while IFS=":$IFS" read -r key values; do
        if [ "$key" = "$field" ]; then
            set -- "$values"
        fi
    done

    if [ "$#" -gt 0 ]; then
        echo "$@"
    else
        return 1
    fi
}

# Like parse_config, but only considers blocks of lines whose first line
# is a certain "Machine: <machine>".
parse_db() {
    field="$1"
    machine="$2"
    set --

    if [ -z "$field" ] || [ -z "$machine" ]; then
        return 1
    fi

    while IFS=":$IFS" read -r key value; do
        # Skip to "Machine: $machine"
        if [ "$key" != "Machine" ] || [ "$value" != "$machine" ]; then
            continue
        fi

        # Try fields until the end of machine (empty line).
        while IFS=":$IFS" read -r key values && [ "$key" != "" ]; do
            if [ "$key" = "$field" ]; then
                set -- "$values"
            fi
        done
    done

    if [ "$#" -gt 0 ]; then
        echo "$@"
    else
        return 1
    fi
}

# Read files but ignore commented lines. Insert newlines between files
# since parse_db uses an empty line as a block delimiter and two files
# could accidentally merge into one block otherwise.
read_files() {
    for f in "$@"; do
        grep -sv '^#' "$f" && echo || :
    done
}

# Check if file is less than a maximum size.
size_check() {
    image="$1"
    max_size="${2:-${MAX_SIZE:-0}}"

    if [ "${max_size}" -gt 0 ]; then
        size="$(stat -c '%s' "$image")"
        if [ "$size" -gt "$max_size" ]; then
            return 1
        fi
    fi
}

# Tries to validate the root=* kernel cmdline parameter.
# See init/do_mounts.c in Linux tree.
check_root_cmdline() {
    d="[0-9]"
    x="[0-9a-f]"
    a="[0-9a-z]"
    uuid="$x{8}-$x{4}-$x{4}-$x{4}-$x{12}"
    ntsig="$x{8}-$x{2}"

    echo "$1" | grep -E -q -x \
        -e "root=$x{4}" \
        -e "root=/dev/nfs" \
        -e "root=/dev/$a+" \
        -e "root=/dev/$a+$d+" \
        -e "root=/dev/$a+p$d+" \
        -e "root=PARTUUID=($uuid|$ntsig)" \
        -e "root=PARTUUID=($uuid|$ntsig)/PARTNROFF=$d+" \
        -e "root=$d+:$d+" \
        -e "root=PARTLABEL=.*"
}

# Gets a kernel cmdline for our root, for when we don't have an initramfs.
get_root_cmdline() {
    rootdev="$(
        findmnt --fstab -M "/" -n -o SOURCE \
            | sed -e 's/\="\(.*\)"$/\=\1/' -e 's/ /\\x20/g' \
    )"

    if [ -n "$rootdev" ]; then
        echo "root=$rootdev"
    else
        return 1
    fi
}
