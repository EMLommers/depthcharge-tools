#!/bin/sh

# Functions to make printing output easier.
info() {
    if [ "$#" -gt 0 ]; then
        echo "$0:" "$@"
    fi
}

warn() {
    info "warning:" "$@" >&2
}

error() {
    info "error:" "$@" >&2
    exit 1
}

usage_error() {
    info "error:" "$@" "\n" >&2
    print_help >&2
    exit 1
}

print_help() {
    : # This should be overridden.
}

# ChromeOS firmware injects one of these values into the cmdline based
# on which boot mechanism is used. A 'secure' argument allows us to
# select for devices where a cros partition is absolutely necessary.
is_cros_machine() {
    case "$(cat /proc/cmdline)" in
        *cros_secure*)
            return 0
            ;;
        *cros_efi*|*cros_legacy*)
            [ "$1" = "secure" ] && return 1
            return 0
            ;;
    esac
    return 1
}

# This function takes some devices (e.g. /dev/sda, /dev/mapper/luks-*,
# /dev/dm-0, /dev/disk/by-partuuid/*), tries to find physical disks
# where they are on.
find_disks() {
    # Use real devices for all. Turns /dev/disk/** into /dev/*.
    for d in "$@"; do
        set -- "$@" "$(readlink -f "$1")"
        shift
    done

    # We can have chains of VG-LV, dm-*, md*, *_crypt, so on. They can
    # resolve to multiple devices. So we keep a stack of devices to
    # search (in $@) and prepend new ones to run in the next cycle of
    # the loop. We also need to keep the results in a stack, so keep
    # them at the end divided with a separator.
    BREAK="{BREAK}"
    set -- "$@" "$BREAK"
    while [ "$#" -gt 0 ]; do
        if [ "$1" = "$BREAK" ]; then
            shift
            break
        else
            dev="$(basename "$1")"
            shift
        fi

        parent="$(readlink -f "/sys/class/block/${dev}/..")" || parent=''
        case "$parent" in
            # VG-LV, sda2_crypt e.g. doesn't exist in /sys/class/block,
            # so readlink fails. We check each dm device's name here to
            # find which dm-* device they actually are.
            '')
                for d in /sys/class/block/dm-*; do
                    d="$(basename "$d")"
                    if grep -qs "$dev" "/sys/class/block/${d}/dm/name"; then
                        set -- "$d" "$@"
                    fi
                done
                ;;
            # dm-* and md* reside on /sys/devices/virtual/block, and
            # have a "slaves" folder for partitions they are built on.
            */virtual/block)
                for d in "/sys/class/block/${dev}/slaves"/*; do
                    set -- "$(basename "$d")" "$@"
                done
                ;;
            # Real partitions e.g. /sys/devices/**/block/sda/sda2
            # but we need their parent, sda.
            */block/*)
                set -- "$(basename "$parent")" "$@"
                ;;
            # These are real disks we can use. Keep them after the
            # separator, without duplicates.
            */block)
                case "$@" in
                    *${BREAK}*${dev}*) continue ;;
                esac
                if [ -b "/dev/${dev}" ]; then
                    set -- "$@" "/dev/${dev}"
                fi
                ;;
            # I don't know what goes here, but let's try the parent.
            *)
                set -- "$(basename "$parent")" "$@"
                ;;
        esac
    done

    echo "$@"
}

# Get a partition device from disk device and partition number.
dev_from_disk_part() {
    case "$1" in
        # mmcblk0 1 -> mmcblk0p1
        # nvme0n1 2 -> nvme0n1p2
        *[0-9]) echo "${1}p${2}" ;;
        # sda 3 -> sda3
        *) echo "${1}${2}" ;;
    esac
}

# Get comma seperated disk device and partition number from a device.
disk_part_from_dev() {
    case "$1" in
        # Don't consider mmcblk1rpmb, mmcblk1boot0 as partitions.
        *boot*|*rpmb*) echo "${1}," ;;
        # mmcblk0p1 -> mmcblk0,1
        # nvme0n1p2 -> nvme0n1,2
        *[0-9]p[0-9]*) echo "${1%p*},${1##*p}" ;;
        # sda1 -> sda,1
        *[0-9]) echo "${1%%[0-9]*},${1##*[!0-9]}" ;;
        *) echo "${1}," ;;
    esac
}

# Find the lowest-priority ChromeOS kernel partition across given disks.
find_depthcharge_part() {
    # Max priority is 15; use 99 to indicate no valid partition.
    best_prio=99
    best_part=""
    prio=99

    for disk in "$@"; do
        for partno in $(cgpt find -n -t kernel "$disk"); do
            prio="$(cgpt show -i "$partno" -P "$disk")" || prio=99
            if [ "$prio" -lt "$best_prio" ]; then
                best_prio="$prio"
                best_part="$(dev_from_disk_part "$disk" "$partno")"
            fi
        done
    done

    if [ -n "$best_part" ]; then
        echo "$best_part"
    else
        return 1
    fi
}

# Read fields from a simple key-value database with sections.
parse_field() {
    field="$1"
    section="$2"
    set --

    # Skip to the chosen section.
    while IFS=: read -r s && [ "$s" != "$section" ]; do
        :
    done

    # Only read fields until the end of section.
    while IFS=":$IFS" read -r key value && [ "$key" != "" ]; do
        if [ "$key" = "$field" ]; then
            set -- "$@" "$value"
        fi
    done

    if [ "$#" -gt 0 ]; then
        echo "$@"
    else
        return 1
    fi
}

# Check if file is less than a maximum size.
size_check() {
    image="$1"
    max_size="${2:-$MAX_SIZE}"

    if [ "${max_size}" -gt 0 ]; then
        size="$(stat -c '%s' "$image")"
        if [ "$size" -gt "$max_size" ]; then
            return 1
        fi
    fi
}
