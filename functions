#!/bin/sh

. "lib/msg.sh"
. "lib/disks.sh"

# ChromeOS firmware injects one of these values into the cmdline based
# on which boot mechanism is used. A 'secure' argument allows us to
# select for devices where a cros partition is absolutely necessary.
is_cros_machine() {
    case "$(cat /proc/cmdline)" in
        *cros_secure*)
            return 0
            ;;
        *cros_efi*|*cros_legacy*)
            [ "$1" = "secure" ] && return 1
            return 0
            ;;
    esac
    return 1
}

# Finds values for a key, among input lines of "<key>: <values>".
parse_config() {
    field="$1"
    set --

    while IFS=":$IFS" read -r key values; do
        if [ "$key" = "$field" ]; then
            set -- "$values"
        fi
    done

    if [ "$#" -gt 0 ]; then
        echo "$@"
    else
        return 1
    fi
}

# Like parse_config, but only considers blocks of lines whose first line
# is a certain "Machine: <machine>".
parse_db() {
    field="$1"
    machine="$2"
    set --

    if [ -z "$field" ] || [ -z "$machine" ]; then
        return 1
    fi

    while IFS=":$IFS" read -r key value; do
        # Skip to "Machine: $machine"
        if [ "$key" != "Machine" ] || [ "$value" != "$machine" ]; then
            continue
        fi

        # Try fields until the end of machine (empty line).
        while IFS=":$IFS" read -r key values && [ "$key" != "" ]; do
            if [ "$key" = "$field" ]; then
                set -- "$values"
            fi
        done
    done

    if [ "$#" -gt 0 ]; then
        echo "$@"
    else
        return 1
    fi
}

# Read files but ignore commented lines. Insert newlines between files
# since parse_db uses an empty line as a block delimiter and two files
# could accidentally merge into one block otherwise.
read_files() {
    for f in "$@"; do
        grep -sv '^#' "$f" && echo || :
    done
}

# Check if file is less than a maximum size.
size_check() {
    image="$1"
    max_size="${2:-${MAX_SIZE:-0}}"

    if [ "${max_size}" -gt 0 ]; then
        size="$(stat -c '%s' "$image")"
        if [ "$size" -gt "$max_size" ]; then
            return 1
        fi
    fi
}

# Tries to validate the root=* kernel cmdline parameter.
# See init/do_mounts.c in Linux tree.
check_root_cmdline() {
    d="[0-9]"
    x="[0-9a-f]"
    a="[0-9a-z]"
    uuid="$x{8}-$x{4}-$x{4}-$x{4}-$x{12}"
    ntsig="$x{8}-$x{2}"

    echo "$1" | grep -E -q -x \
        -e "root=$x{4}" \
        -e "root=/dev/nfs" \
        -e "root=/dev/$a+" \
        -e "root=/dev/$a+$d+" \
        -e "root=/dev/$a+p$d+" \
        -e "root=PARTUUID=($uuid|$ntsig)" \
        -e "root=PARTUUID=($uuid|$ntsig)/PARTNROFF=$d+" \
        -e "root=$d+:$d+" \
        -e "root=PARTLABEL=.*"
}

# Gets a kernel cmdline for our root, for when we don't have an initramfs.
get_root_cmdline() {
    rootdev="$(
        findmnt --fstab -M "/" -n -o SOURCE \
            | sed -e 's/\="\(.*\)"$/\=\1/' -e 's/ /\\x20/g' \
    )"

    if [ -n "$rootdev" ]; then
        echo "root=$rootdev"
    else
        return 1
    fi
}
