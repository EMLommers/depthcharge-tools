#!/bin/sh
set -e

# Import common functions
. "./functions"

: "${CACHE:=/tmp/depthcharge-support/cache}"
mkdir -p "$CACHE"

print_help() {
cat <<EOF
Usage: update-depthcharge [options]

Options:
 -h, --help              Show this help message.
 -a, --all               Rebuild depthcharge images for all versions.
 -k, --kversion VERSION  Use a specific kernel version instead of the
                         latest version.
 -n, --no-write          Don't write the image to disk.
EOF
}

while [ "$#" -gt 0 ]; do
    case "$1" in
        -h|--help)
            print_help
            exit 0
            ;;
        -k|--kversion)
            KVERSION="$2"
            shift 2
            ;;
        -a|--all)
            ALL_IMAGES=yes
            shift 1
            ;;
        -n|--no-write)
            NO_WRITE=yes
            shift 1
            ;;
        --)
            shift
            break
            ;;
        -*)
            usage_error "Option '$1' not understood."
            ;;
        *)
            usage_error "Argument '$1' not understood."
            ;;
    esac
done

# Use latest version if omitted.
if [ -z "$KVERSION" ]; then
    KVERSION="$( \
        linux-version list \
            | linux-version sort --reverse \
            | head -1 \
    )"
    info "Defaulting to latest kernel version '$KVERSION'."
fi

# Load user configuration and machine database.
if [ -z "$USER_DB" ]; then
    USER_DB="$(grep -v '^#' config 2>/dev/null)" || :
fi

if [ -z "$MACHINE_DB" ]; then
    MACHINE_DB="$(grep -v '^#' machines 2>/dev/null)" || :
fi

get_config() {
    field="$1"
    machine="${2:-$MACHINE}"

    echo "$USER_DB" | parse_field "$field" "config" \
        || echo "$MACHINE_DB" | parse_field "$field" "config" \
        || echo "$USER_DB" | parse_field "$field" "$machine" \
        || echo "$MACHINE_DB" | parse_field "$field" "$machine" \
        || echo "$USER_DB" | parse_field "$field" "defaults" \
        || echo "$MACHINE_DB" | parse_field "$field" "defaults"
}

# Detect machine, but allow overriding via user config.
if [ -n "$MACHINE" ]; then
    info "Overriding machine '$MACHINE' from environment variable."
elif MACHINE="$(get_config machine)"; then
    info "Overriding machine '$MACHINE' from user configuration."
elif MACHINE="$(cat /proc/device-tree/model 2>/dev/null)"; then
    info "Detected machine '$MACHINE' from device-tree model."
else
    error "Failed to detect machine."
fi

# Load machine-specific settings.
DTB_NAME="$(get_config dtb-name)" || :
MAX_SIZE="$(get_config max-size)" || :

# Load user configuration.
CMDLINE="$(get_config cmdline)" || :
COMPRESS="$(get_config compress)" || :
DESCRIPTION_FMT="$(get_config description)" || :

generate_image() {
    kversion="$1"
    output="${2:-${CACHE}/depthcharge.img-${kversion}}"
    info "Trying to generate a depthcharge image for version '$kversion'."

    # These variables are understood by mkdepthcharge.
    VMLINUZ="/boot/vmlinuz-${kversion}"
    INITRAMFS="/boot/initrd.img-${kversion}"
    DTBS="$(find "/usr/lib/linux-image-${kversion}" -name "$DTB_NAME")"
    DESCRIPTION="$(printf "$DESCRIPTION_FMT" "$kversion")"
    export VMLINUZ INITRAMFS DTBS
    export CMDLINE COMPRESS DESCRIPTION

    # Decompress kernel if packaged as gzip compressed.
    if { command -v gzip && gzip -t "$VMLINUZ"; } >/dev/null 2>&1; then
        info "Packaged kernel is gzip compressed, decompressing."
        gzip -d <"$VMLINUZ" >"${CACHE}/vmlinuz-gunzipped-${kversion}" \
            && VMLINUZ="${CACHE}/vmlinuz-gunzipped-${kversion}"
    fi

    if [ ! -r "$INITRAMFS" ]; then
        error "No initramfs found for kernel version '${kversion}'."
    fi

    if [ -z "$DTBS" ]; then
        error "No dtb file '$DTB_NAME' found for version '$kversion'."
    fi

    # Try to keep the output reproducible. Initramfs date is bound to be
    # later than vmlinuz date, so prefer that if possible.
    if [ -z "$SOURCE_DATE_EPOCH" ]; then
        SOURCE_DATE_EPOCH="$(
            stat -c "%Y" "$INITRAMFS" || stat -c "%Y" "$VMLINUZ" \
        )" || error "Couldn't determine a date from initramfs nor vmlinuz."
        export SOURCE_DATE_EPOCH
    fi

    info "Generating depthcharge image for kernel version '$kversion':"
    if [ -n "$COMPRESS" ]; then
        info "Trying with user-chosen compression '$COMPRESS':"
        ./mkdepthcharge -o "$output" \
            || error "Failed to create depthcharge image."
    else
        for compress in none lz4 lzma; do
            info "Trying with compression set to '$compress'."
            ./mkdepthcharge -C "$compress" -o "$output" \
                || error "Failed to create depthcharge image."
            if size_check "$output" "$MAX_SIZE"; then
                break
            else
                warn "Image is too big with compression '$compress'."
            fi
        done
    fi

    info "Checking generated image size against firmware limits."
    size_check "$output" "$MAX_SIZE" \
        || error "Depthcharge image '$output' is too big to boot."
}

write_image() {
    kversion="$1"
    image="${2:-${CACHE}/depthcharge.img-${kversion}}"
    info "Preparing system to use depthcharge image '$image' on next boot."

    if [ ! -r "$image" ]; then
        error "Depthcharge image '$image' not found or is not readable."
    fi

    info "Checking image size against firmware limits."
    size_check "$image" "$MAX_SIZE" \
        || error "Depthcharge image '$image' is too big to boot."

    # Disks containing /boot and / should be available during boot,
    # so we can look there for a partition to write our boot image.
    info "Identifying disks containing root and boot partitions."
    root="$(findmnt --fstab -M "/" --evaluate -n -o SOURCE)" || :
    boot="$(findmnt --fstab -M "/boot" --evaluate -n -o SOURCE)" || :
    if [ -z "$root" ] && [ -z "$boot" ]; then
        error "Couldn't find devices for neither / nor /boot from fstab."
    else
        disks="$(find_disks $boot $root)" \
            || error "Couldn't find physical disks for neither" \
                "/ device '$root' nor /boot device '$boot'."
    fi

    info "Searching for ChromeOS kernel partitions (on $disks)."
    target="$(find_depthcharge_part $disks)" \
        || error "No usable ChromeOS kernel partition found (on $disks)."
    if [ ! -b "$target" ]; then
        error "Target device '$target' is not a valid block device."
    elif [ ! -w "$target" ]; then
        error "Target device '$target' is not writable."
    fi
    info "Chose partition '$target' as the target partition."

    pair="$(disk_part_from_dev "$target")"
    disk="${pair%,*}"
    part="${pair#*,}"
    if [ ! -b "$disk" ]; then
        error "Target disk '$disk' is not a valid block device."
    elif [ ! -w "$disk" ]; then
        error "Target disk '$disk' is not writable."
    fi
    case "$part" in
        *[!0-9]*)
            error "Parsed invalid partition number for '$target'."
            ;;
    esac

    info "Checking image size against partition size."
    size_check "$image" "$(blockdev --getsize64 "$target")" \
        || error "Image '$image' is bigger than partition '$target'."

    info "Writing depthcharge image '$image' to partition '$target':"
    dd if="$image" of="$target" \
        || error "Failed to write image '$image' to partition '$target'."

    info "Setting '$target' as the highest-priority bootable partition."
    cgpt add -i "$part" -T 1 -S 0 "$disk" \
        || error "Failed to set partition '$target' as bootable."
    cgpt prioritize -i "$part" "$disk" \
        || error "Failed to prioritize partition '$target'."
}

if [ "$ALL_IMAGES" = yes ]; then
    for v in $(linux-version list | linux-version sort); do
        if generate_image "$v"; then
            continue
        elif [ "$v" = "$KVERSION" ]; then
            error "Couldn't generate image for chosen version '$v'."
        else
            warn "Couldn't generate image for version '$v', ignoring."
        fi
    done
else
    generate_image "$KVERSION" \
        || error "Couldn't generate image for chosen version '$v'."
fi

if [ "$NO_WRITE" != yes ]; then
    write_image "$KVERSION" \
        || error "Couldn't write image to disk for chosen version '$v'."
fi
