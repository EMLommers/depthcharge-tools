#!/bin/sh
set -e

# Import common functions
. "./functions"

: "${CACHE:=/tmp/depthcharge-support/cache}"
mkdir -p "$CACHE"

print_help() {
cat <<EOF
Usage: update-depthcharge [-k VERSION]

Options:
 -h, --help              Show this help message.
 -k, --kversion VERSION  Use a specific kernel version instead of the
                         latest version.
EOF
}

while [ "$#" -gt 0 ]; do
    case "$1" in
        -h|--help)
            print_help
            exit 0
            ;;
        -k|--kversion)
            KVERSION="$2"
            shift 2
            ;;
        --)
            shift
            break
            ;;
        -*)
            usage_error "Option '$1' not understood."
            ;;
        *)
            usage_error "Argument '$1' not understood."
            ;;
    esac
done

# Use latest version if omitted.
if [ -z "$KVERSION" ]; then
    KVERSION="$( \
        linux-version list \
            | linux-version sort --reverse \
            | head -1 \
    )"
    info "Defaulting to latest kernel version '$KVERSION'."
fi

# Load machine-specific settings.
if [ -z "$MACHINE" ]; then
    MACHINE="$(cat /proc/device-tree/model)"
    info "Using settings for detected machine '$MACHINE'."
fi
DTB_NAME="$(machine_field dtb-name)"
MAX_SIZE="$(machine_field max-size)" || MAX_SIZE=0

generate_image() {
    kversion="$1"
    output="${2:-${CACHE}/depthcharge.img-${kversion}}"
    info "Trying to generate a depthcharge image for version '$kversion'."

    # These variables are understood by mkdepthcharge.
    VMLINUZ="/boot/vmlinuz-${kversion}"
    INITRAMFS="/boot/initrd.img-${kversion}"
    DTBS="$(find "/usr/lib/linux-image-${kversion}" -name "$DTB_NAME")"
    export VMLINUZ INITRAMFS DTBS

    if [ ! -r "$INITRAMFS" ]; then
        error "No initramfs found for kernel version '${kversion}'."
    fi

    if [ -z "$DTBS" ]; then
        error "No dtb file '$DTB_NAME' found for version '$kversion'."
    fi

    # Try to keep the output reproducible. Initramfs date is bound to be
    # later than vmlinuz date, so prefer that if possible.
    if [ -z "$SOURCE_DATE_EPOCH" ]; then
        SOURCE_DATE_EPOCH="$(
            stat -c "%Y" "$INITRAMFS" || stat -c "%Y" "$VMLINUZ" \
        )" || error "Couldn't determine a date from initramfs nor vmlinuz."
        export SOURCE_DATE_EPOCH
    fi

    info "Generating depthcharge image for kernel version '$kversion'"
    ./mkdepthcharge \
        -c "console=tty1 quiet splash kern_guid=%U" \
        -C "lz4" \
        -n "Debian with linux-image-${kversion}" \
        -o "$output" \
        || error "Failed to create depthcharge image."

    info "Checking generated image size against firmware limits."
    size_check "$output" \
        || error "Depthcharge image '$output' is too big to boot."
}

write_image() {
    kversion="$1"
    image="${2:-${CACHE}/depthcharge.img-${kversion}}"
    info "Preparing system to use depthcharge image '$image' on next boot."

    if [ ! -r "$image" ]; then
        error "Depthcharge image '$image' not found or is not readable."
    fi

    info "Checking image size against firmware limits."
    size_check "$image" \
        || error "Depthcharge image '$image' is too big to boot."

    # Disks containing /boot and / should be available during boot,
    # so we can look there for a partition to write our boot image.
    info "Identifying disks containing root and boot partitions."
    root="$(findmnt --fstab -M "/" --evaluate -n -o SOURCE)" || :
    boot="$(findmnt --fstab -M "/boot" --evaluate -n -o SOURCE)" || :
    if [ -z "$root" ] && [ -z "$boot" ]; then
        error "Couldn't find devices for neither / nor /boot from fstab."
    else
        disks="$(find_disks $boot $root)" \
            || error "Couldn't find physical disks for neither" \
                "/ device '$root' nor /boot device '$boot'."
    fi

    info "Searching for ChromeOS kernel partitions (on $disks)."
    target="$(find_depthcharge_part $disks)" \
        || error "No usable ChromeOS kernel partition found (on $disks)."
    if [ ! -b "$target" ]; then
        error "Target device '$target' is not a valid block device."
    elif [ ! -w "$target" ]; then
        error "Target device '$target' is not writable."
    fi
    info "Chose partition '$target' as the target partition."

    pair="$(disk_part_from_dev "$target")"
    disk="${pair%,*}"
    part="${pair#*,}"
    if [ ! -b "$disk" ]; then
        error "Target disk '$disk' is not a valid block device."
    elif [ ! -w "$disk" ]; then
        error "Target disk '$disk' is not writable."
    fi
    case "$part" in
        *[!0-9]*)
            error "Parsed invalid partition number for '$target'."
            ;;
    esac

    info "Checking image size against partition size."
    size_check "$image" "$(blockdev --getsize64 "$target")" \
        || error "Image '$image' is bigger than partition '$target'."

    info "Writing depthcharge image '$image' to partition '$target':"
    dd if="$image" of="$target" \
        || error "Failed to write image '$image' to partition '$target'."

    info "Setting '$target' as the highest-priority bootable partition."
    cgpt add -i "$part" -T 1 -S 0 "$disk" \
        || error "Failed to set partition '$target' as bootable."
    cgpt prioritize -i "$part" "$disk" \
        || error "Failed to prioritize partition '$target'."
}

generate_image "$KVERSION"
write_image "$KVERSION"
