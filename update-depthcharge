#!/bin/sh
set -e

print_help() {
cat <<EOF
Usage: update-depthcharge [options]

Options:
 -h, --help              Show this help message.
 -v, --verbose           Print more detailed output.
 -a, --all               Rebuild depthcharge images for all versions.
 -k, --kversion VERSION  Use a specific kernel version instead of the
                         latest version.
 -n, --no-write          Don't write the image to disk.
EOF
}

# Prefer to use files from the repository.
if [ -n "$CHECKOUT" ]; then
    : "${FUNCTIONS:=${CHECKOUT}/functions}"
    : "${DB_FILE:=${CHECKOUT}/conf/db}"
    : "${CONFIG_FILE:=${CHECKOUT}/conf/config}"
    : "${CONFIG_DIR:=${CHECKOUT}/conf/config.d}"
    : "${USERDB_FILE:=${CHECKOUT}/conf/userdb}"
    : "${USERDB_DIR:=${CHECKOUT}/conf/userdb.d}"
    : "${CACHE:=$(temp_folder update-depthcharge)}"
fi

# Things we might want to override during testing.
: "${PROC_DT_MODEL:=/proc/device-tree/model}"

# Distro-specific paths for installed files.
: "${FUNCTIONS:=/usr/share/depthcharge-support/functions}"
: "${DB_FILE:=/usr/share/depthcharge-support/db}"
: "${USERDB_FILE:=/etc/depthcharge-support/userdb}"
: "${USERDB_DIR:=/etc/depthcharge-support/userdb.d}"
: "${CONFIG_FILE:=/etc/depthcharge-support/config}"
: "${CONFIG_DIR:=/etc/depthcharge-support/config.d}"
: "${CACHE:=/var/cache/depthcharge-support}"

# Import common functions.
. "$FUNCTIONS"

# Default values to be used in absence of machine-specific ones.
: "${DEFAULT_CMDLINE:=quiet splash}"
: "${DEFAULT_COMPRESS:=none lz4 lzma}"
: "${DEFAULT_MAX_SIZE:=33554432}"

# A '%s' in these values will be replaced with a kernel version if any.
: "${VMLINUZ_FMT:=/boot/vmlinuz-%s}"
: "${INITRAMFS_FMT=/boot/initrd.img-%s}"
: "${DTBS_DIR_FMT=/usr/lib/linux-image-%s}"
: "${DESCRIPTION_FMT=Debian with linux-image-%s}"
: "${OUTPUT_PATH_FMT:=${CACHE}/depthcharge.img-%s}"

kernel_versions() {
    linux-version list | linux-version sort
}

parse_args() {
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -h|--help)
                print_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=yes
                shift
                ;;
            -k|--kversion)
                KVERSION="$2"
                shift 2
                ;;
            -a|--all)
                ALL_IMAGES=yes
                shift 1
                ;;
            -n|--no-write)
                NO_WRITE=yes
                shift 1
                ;;
            --)
                shift
                break
                ;;
            -*)
                usage_error "Option '$1' not understood."
                ;;
            *)
                usage_error "Argument '$1' not understood."
                ;;
        esac
    done

    # Use latest version if omitted.
    if [ -z "$KVERSION" ]; then
        KVERSION="$(kernel_versions | tail -1)" \
            || error "Couldn't figure out latest kernel version."
        info "Defaulting to latest kernel version '$KVERSION'."
    fi
}

# Load user configuration and machine database.
set_config_var() {
    if [ -z "$CONFIG" ]; then
        CONFIG="$( \
            read_files "$CONFIG_FILE" "${CONFIG_DIR}"/* \
        )" || error "Could not read configuration files."
    fi
}

set_machine_db() {
    if [ -z "$MACHINE_DB" ]; then
        MACHINE_DB="$( \
            read_files "$DB_FILE" "$USERDB_FILE" "${USERDB_DIR}"/* \
        )" || error "Could not read machine database."
    fi
}

get_config() {
    field="$1"
    machine="${2:-$MACHINE}"

    echo "$CONFIG" | parse_field "$field" \
        || echo "$MACHINE_DB" | parse_machine_field "$machine" "$field"
}

# Detect machine, but allow overriding via user config.
set_machine() {
    if [ -n "$MACHINE" ]; then
        info "Overriding machine '$MACHINE' from environment variable."
    elif MACHINE="$(get_config Force-Machine)"; then
        info "Overriding machine '$MACHINE' from user configuration."
    elif MACHINE="$(cat "$PROC_DT_MODEL" 2>/dev/null)"; then
        info "Detected machine '$MACHINE' from device-tree model."
    else
        error "Failed to detect machine."
    fi
}

load_configs() {
    # Load machine-specific settings.
    CONFIG_DTB_NAME="$(get_config DTB-Name)" || :
    CONFIG_MAX_SIZE="$(get_config Depthcharge-Max-Size)" || :

    # Load user configuration.
    CONFIG_CMDLINE="$(get_config Kernel-Cmdline)" || :
    CONFIG_COMPRESS="$(get_config Kernel-Compression)" || :

    # Load defaults if unset
    : "${CONFIG_DTB_NAME:=}"
    : "${CONFIG_MAX_SIZE:=$DEFAULT_MAX_SIZE}"
    : "${CONFIG_CMDLINE:=$DEFAULT_CMDLINE}"
    : "${CONFIG_COMPRESS:=$DEFAULT_COMPRESS}"
}

generate_image() {
    kversion="${1:-$KVERSION}"
    output="${2:-$(printf "$OUTPUT_PATH_FMT" "$kversion")}"
    info "Trying to generate a depthcharge image for version '$kversion'."

    VMLINUZ="$(printf "$VMLINUZ_FMT" "$kversion")"
    if [ ! -r "$VMLINUZ" ]; then
        error "No vmlinuz ('$VMLINUZ') found for version '${kversion}'."
    fi

    INITRAMFS="$(printf "$INITRAMFS_FMT" "$kversion")"
    if [ ! -r "$INITRAMFS" ]; then
        warn "No initramfs ('$INITRAMFS') found for version '${kversion}'."
        INITRAMFS=""
    fi

    DTBS_DIR="$(printf "$DTBS_DIR_FMT" "$kversion")"
    DTBS="$(find "$DTBS_DIR" -name "$CONFIG_DTB_NAME")"
    if [ -z "$DTBS" ]; then
        error "No dtb file '$CONFIG_DTB_NAME' found for version '$kversion'."
    fi

    CMDLINE="$CONFIG_CMDLINE"
    # Custom kernels might still be able to boot without an initramfs,
    # but we need to inject a root= parameter for that.
    if [ -z "$INITRAMFS" ]; then
        info "Booting without an initramfs requires a root parameter" \
            "in the kernel cmdline."
        case "$CMDLINE_USER" in
            # Skip if the user specified a root=* in cmdline.
            *root=*)
                info "Keeping root parameter as in user configured cmdline."
                ;;
            *)
                rootcmd="$(get_root_cmdline)" \
                    || error "Couldn't figure out a root cmdline parameter."
                check_root_cmdline "$rootcmd" \
                    || error "An initramfs is required for '$rootcmd'."
                info "Prepending '$rootcmd' to the kernel cmdline."
                CMDLINE="$rootcmd $CMDLINE"
                ;;
        esac
    fi

    COMPRESS_TYPES="$CONFIG_COMPRESS"
    if [ -z "$COMPRESS_TYPES" ]; then
        warn "Compression is set to nothing in config, assuming 'none'."
        COMPRESS_TYPES=none
    fi

    # We must do this here and not outside with others since --all
    # builds multiple '$kversion's where '$KVERSION' is the latest one.
    DESCRIPTION="$(printf "$DESCRIPTION_FMT" "$kversion")"

    # These variables are understood by mkdepthcharge.
    export VMLINUZ INITRAMFS DTBS
    export CMDLINE COMPRESS DESCRIPTION

    # Try to keep the output reproducible. Initramfs date is bound to be
    # later than vmlinuz date, so prefer that if possible.
    if [ -z "$SOURCE_DATE_EPOCH" ]; then
        SOURCE_DATE_EPOCH="$(
            stat -c "%Y" "$INITRAMFS" || stat -c "%Y" "$VMLINUZ" \
        )" || error "Couldn't determine a date from initramfs nor vmlinuz."
        export SOURCE_DATE_EPOCH
    fi

    info "Generating depthcharge image for kernel version '$kversion':"
    for COMPRESS in $COMPRESS_TYPES; do
        info "Trying with compression set to '$COMPRESS'."
        mkdepthcharge -o "$output" \
            || error "Failed to create depthcharge image."
        if size_check "$output" "$CONFIG_MAX_SIZE"; then
            break
        else
            warn "Image is too big with compression '$COMPRESS'."
        fi
    done

    # This is redundant now, but here just to raise an error.
    info "Checking generated image size against firmware limits."
    size_check "$output" "$CONFIG_MAX_SIZE" \
        || error "Depthcharge image '$output' is too big to boot."
}

write_image() {
    kversion="${1:-$KVERSION}"
    image="${2:-$(printf "$OUTPUT_PATH_FMT" "$kversion")}"
    info "Preparing system to use depthcharge image '$image' on next boot."

    if [ ! -r "$image" ]; then
        error "Depthcharge image '$image' not found or is not readable."
    fi

    info "Checking image size against firmware limits."
    size_check "$image" "$CONFIG_MAX_SIZE" \
        || error "Depthcharge image '$image' is too big to boot."

    # Disks containing /boot and / should be available during boot,
    # so we can look there for a partition to write our boot image.
    info "Identifying disks containing root and boot partitions."
    disks="$(bootable_disks)" \
        || error "Couldn't find physical disks for neither / nor /boot."

    info "Searching for ChromeOS kernel partitions (on $disks)."
    target="$(
        depthcharge_parts_table "$disks" \
            | sort \
            | head -1  \
            | { read -r S P T dev && printf "%s" "$dev"; } \
    )" || error "No usable ChromeOS kernel partition found (on $disks)."
    if [ ! -b "$target" ]; then
        error "Target device '$target' is not a valid block device."
    elif [ ! -w "$target" ]; then
        error "Target device '$target' is not writable."
    fi
    info "Chose partition '$target' as the target partition."

    disk="$(disk_from_partdev "$target")"
    partno="$(partno_from_partdev "$target")"
    if [ ! -b "$disk" ]; then
        error "Target disk '$disk' is not a valid block device."
    elif [ ! -w "$disk" ]; then
        error "Target disk '$disk' is not writable."
    fi
    case "$partno" in
        *[!0-9]*)
            error "Parsed invalid partition number for '$target'."
            ;;
    esac

    info "Checking image size against partition size."
    size_check "$image" "$(blockdev --getsize64 "$target")" \
        || error "Image '$image' is bigger than partition '$target'."

    info "Writing depthcharge image '$image' to partition '$target':"
    dd if="$image" of="$target" \
        || error "Failed to write image '$image' to partition '$target'."

    info "Setting '$target' as the highest-priority bootable partition."
    cgpt_ add -i "$partno" -T 1 -S 0 "$disk" \
        || error "Failed to set partition '$target' as bootable."
    cgpt_ prioritize -i "$partno" "$disk" \
        || error "Failed to prioritize partition '$target'."
}

main() {
    parse_args "$@"

    if [ "$VERBOSE" != yes ]; then
        exec >/dev/null
    fi

    set_config_var
    set_machine_db
    set_machine
    load_configs

    if [ "$ALL_IMAGES" = yes ]; then
        for v in $(kernel_versions); do
            if generate_image "$v"; then
                continue
            elif [ "$v" = "$KVERSION" ]; then
                error "Couldn't generate image for chosen version '$v'."
            else
                warn "Couldn't generate image for version '$v', ignoring."
            fi
        done
    else
        generate_image "$KVERSION" \
            || error "Couldn't generate image for chosen version '$v'."
    fi

    if [ "$NO_WRITE" != yes ]; then
        write_image "$KVERSION" \
            || error "Couldn't write image to disk for chosen version '$v'."
    fi
}

main "$@"
