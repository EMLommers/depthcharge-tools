#!/bin/sh
set -eu
PROG="depthchargectl"
usage() {
cat <<EOF
Usage:
 depthchargectl [options] command ...

Manage ChromeOS kernel partitions.

Supported commands:
 build          Buld a depthcharge image for the running system.
 check          Check if a depthcharge image can be booted.
 partitions     List ChromeOS kernel partitions.
 rm             Remove images and disable partitions containing them.
 set-good       Set the current partition as successfully booted.
 target         Choose or validate a ChromeOS Kernel partition to use.
 write          Write an image to a ChromeOS kernel partition.

Global options:
 -h, --help                 Show the help message for the given command.
     --version              Print program version.
 -v, --verbose              Print info messages to stderr.
EOF
}

version() {
    printf "%s %s %s" \
        "${PACKAGENAME:-depthcharge-tools}" \
        "${PROG:-depthchargectl}" \
        "${VERSION:+version }${VERSION:-(unversioned)}"
}

# These values are replaced by the makefile.
PACKAGENAME="depthcharge-tools"
VERSION=""
DATADIR=""
SYSCONFDIR=""
LOCALSTATEDIR=""
DEFAULT_CMDLINE="console=tty0 quiet splash"
DEFAULT_NOINITRAMFS="no"
DEFAULT_COMPRESS="none lz4 lzma"
DEFAULT_MAX_SIZE="33554432"
DEFAULT_DTB_NAME=""
DEFAULT_FORMAT="fit"
DEFAULT_VBOOT_DEVKEYS="/usr/share/vboot/devkeys"
DEFAULT_VBOOT_KEYBLOCK="${DEFAULT_VBOOT_DEVKEYS}/kernel.keyblock"
DEFAULT_VBOOT_SIGNPUBKEY="${DEFAULT_VBOOT_DEVKEYS}/kernel_subkey.vbpubk"
DEFAULT_VBOOT_SIGNPRIVATE="${DEFAULT_VBOOT_DEVKEYS}/kernel_data_key.vbprivk"
# ---

readonly PACKAGENAME DATADIR SYSCONFDIR LOCALSTATEDIR
readonly DEFAULT_CMDLINE DEFAULT_COMPRESS DEFAULT_MAX_SIZE DEFAULT_DTB_NAME
readonly DEFAULT_VBOOT_DEVKEYS DEFAULT_VBOOT_KEYBLOCK
readonly DEFAULT_VBOOT_SIGNPUBKEY DEFAULT_VBOOT_SIGNPRIVATE

# If system directories are set, use them, or use files in the repo.
REPO="${0%/*}"
DB_FILE="${DATADIR:-$REPO/conf}${DATADIR:+/$PACKAGENAME}/db"
USERDB_FILE="${SYSCONFDIR:-$REPO/conf}${SYSCONFDIR:+/$PACKAGENAME}/userdb"
CONFIG_FILE="${SYSCONFDIR:-$REPO/conf}${SYSCONFDIR:+/$PACKAGENAME}/config"
FUNCTIONS_DIR="${DATADIR:-$REPO/lib}${DATADIR:+/$PACKAGENAME}"
COMMANDS_DIR="${DATADIR:-$REPO/lib}${DATADIR:+/$PACKAGENAME}/depthchargectl"
IMAGES_DIR="${LOCALSTATEDIR:-$REPO}${LOCALSTATEDIR:+/$PACKAGENAME}/images"

readonly DB_FILE USERDB_FILE CONFIG_FILE
readonly FUNCTIONS_DIR COMMANDS_DIR IMAGES_DIR

. "${FUNCTIONS_DIR}/msg.sh"
. "${FUNCTIONS_DIR}/disks.sh"
. "${FUNCTIONS_DIR}/ifs.sh"
. "${FUNCTIONS_DIR}/tmp.sh"
. "${FUNCTIONS_DIR}/config.sh"
. "${FUNCTIONS_DIR}/kernel.sh"


# Parse options and arguments
# ---------------------------

set_cmd() {
    if [ -n "${COMMAND:-}" ]; then
        error "Can't set command twice ('$COMMAND', '$1')."
    fi

    COMMAND="$1"
    readonly COMMAND

    cmd="${COMMANDS_DIR}/${COMMAND}.sh"
    if [ ! -r "$cmd" ]; then
        usage_error "'$COMMAND' is not a valid depthchargectl command."
    fi

    # This should give us cmd_args, cmd_defaults and cmd_main functions.
    # It also replaces the usage text with its own.
    . "$cmd"
}

# Check verbose options before printing anything.
for arg in "$@"; do
    case "${arg:-}" in
        -v|--verbose) VERBOSE=yes ;;
        --) break ;;
    esac
done

while [ "$#" -gt 0 ]; do
    case "$1" in
        # Global options:
        -h|--help)      usage;          exit 0 ;;
        --version)      version;        exit 0 ;;
        -v|--verbose)   VERBOSE=yes;    shift; continue ;;

        # May be command options, but not commands themselves.
        -*) if [ -z "${COMMAND:-}" ]; then
                usage_error "Global option '$1' not understood."
            fi
            ;;
    esac

    # Commands or command arguments.
    if [ -z "${COMMAND:-}" ]; then
        set_cmd "$1"
        shift
    else
        # Should return number of elemets to shift, never zero.
        if cmd_args "$@"; then
            error "Parser for command '$COMMAND' couldn't parse args."
        else
            shift "$?"
        fi
    fi
done


# User configuration
# ------------------

CONFIG="$(read_files "$CONFIG_FILE" "${CONFIG_FILE}.d"/*)" \
    || error "Could not read configuration files."
readonly CONFIG

config() {
    printf "%s\n" "$CONFIG" | parse_field "$1"
}

# User configuration.
CONFIG_MACHINE="$(config Machine)" || :
CONFIG_COMPRESS="$(config Kernel-Compression)" || :
CONFIG_CMDLINE="$(config Kernel-Cmdline)" || :
CONFIG_NOINITRAMFS="$(config Ignore-Initramfs)" :
CONFIG_VBOOT_DEVKEYS="$(config Vboot-Keys-Dir)" || :
CONFIG_VBOOT_KEYBLOCK="$(config Vboot-Keyblock)" || :
CONFIG_VBOOT_SIGNPRIVATE="$(config Vboot-Private-Key)" || :
CONFIG_VBOOT_SIGNPUBKEY="$(config Vboot-Public-Key)" || :

if [ -n "${CONFIG_VBOOT_DEVKEYS:-}" ]; then
    : "${CONFIG_VBOOT_KEYBLOCK:="${CONFIG_VBOOT_DEVKEYS}/kernel.keyblock"}"
    : "${CONFIG_VBOOT_SIGNPUBKEY:="${CONFIG_VBOOT_DEVKEYS}/kernel_subkey.vbpubk"}"
    : "${CONFIG_VBOOT_SIGNPRIVATE:="${CONFIG_VBOOT_DEVKEYS}/kernel_data_key.vbprivk"}"
fi

: "${CONFIG_CMDLINE:="$DEFAULT_CMDLINE"}"
: "${CONFIG_CMDLINE:="$DEFAULT_NOINITRAMFS"}"
: "${CONFIG_VBOOT_DEVKEYS:="$DEFAULT_VBOOT_DEVKEYS"}"
: "${CONFIG_VBOOT_KEYBLOCK:="${DEFAULT_VBOOT_KEYBLOCK}"}"
: "${CONFIG_VBOOT_SIGNPUBKEY:="${DEFAULT_VBOOT_SIGNPUBKEY}"}"
: "${CONFIG_VBOOT_SIGNPRIVATE:="${DEFAULT_VBOOT_SIGNPRIVATE}"}"

readonly CONFIG_MACHINE CONFIG_COMPRESS CONFIG_CMDLINE CONFIG_NOINITRAMFS
readonly CONFIG_VBOOT_DEVKEYS CONFIG_VBOOT_KEYBLOCK
readonly CONFIG_VBOOT_SIGNPUBKEY CONFIG_VBOOT_SIGNPRIVATE


# Machine database
# ----------------

MACHINEDB="$(read_files "$DB_FILE" "$USERDB_FILE" "${USERDB_FILE}.d"/*)" \
    || error "Could not read machine database."
readonly MACHINEDB

machine_config() {
    printf "%s\n" "$MACHINEDB" \
        | parse_machine_field "${2:-$MACHINE}" "$1"
}

detect_machine() {
    if [ -f /proc/device-tree/model ] \
        && machine="$(tr -d "\0" </proc/device-tree/model)" \
        && [ -n "$machine" ];
    then
        info "Detected machine from device-tree: '$machine'"
        printf "%s\n" "$machine"
    else
        return 1
    fi
}

# We will check this in subcommands, not here, since only some commands
# are machine-dependent.
machine_is_supported() {
    printf "%s\n" "$MACHINEDB" \
        | parse_machine_exists "${1:-$MACHINE}"
}

DETECTED_MACHINE="$(detect_machine)"
if [ -n "$CONFIG_MACHINE" ] ; then
    info "Overriding detected machine '$DETECTED_MACHINE' with" \
        "'$CONFIG_MACHINE' from user configuration."
    MACHINE="$CONFIG_MACHINE"
else
    MACHINE="$DETECTED_MACHINE"
fi

MACHINE_FORMAT="$(machine_config Image-Format)" || :
MACHINE_DTB_NAME="$(machine_config DTB-Name)" || :
MACHINE_MAX_SIZE="$(machine_config Max-Size)" || :
MACHINE_COMPRESS="$(machine_config Kernel-Compression)" || :

: "${MACHINE_FORMAT:="${DEFAULT_FORMAT}"}"
: "${MACHINE_DTB_NAME:="${DEFAULT_DTB_NAME}"}"
: "${MACHINE_MAX_SIZE:="${DEFAULT_MAX_SIZE}"}"
: "${MACHINE_COMPRESS:="${DEFAULT_COMPRESS}"}"

readonly DETECTED_MACHINE MACHINE
readonly MACHINE_FORMAT MACHINE_DTB_NAME MACHINE_MAX_SIZE MACHINE_COMPRESS


# Set argument defaults
# ---------------------

# List partitions by default.
if [ -z "${COMMAND:-}" ]; then
    set_cmd partitions
fi

# Set defaults for the active command.
cmd_defaults

# Verbosity options.
: "${VERBOSE:=no}"
: "${QUIET:=no}"
: "${SILENT:=no}"


# Execute chosen command
# ----------------------

cmd_main
