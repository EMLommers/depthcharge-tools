#!/bin/sh
set -e

usage() {
cat <<EOF
Usage: mkdepthcharge [options] -o FILE [--] vmlinuz [initrd] [dtb ...]

Options:
 -h, --help              Show this help message.
 -v, --verbose           Print more detailed output.
 -o, --output FILE       Write resulting image to FILE.
 -c, --cmdline CMD       Command-line parameters for the kernel. Can
                         be used multiple times to append new values.
 -C, --compress TYPE     Compress kernel with one of: none, lz4, lzma.
 -n, --description DESC  Description to use as a mkimage argument.
EOF
}

# We need to use a non-space separator to support paths with spaces.
# Instead of hard-coding it everywhere, let's put it in a variable.
# To support e.g. DTBS=$(find ...) we also need a newline in the IFS.
# Also keep a copy of the original so we can restore it.
SEP=","
NEWLINE="
"
ORIG_IFS="$IFS"
CUSTOM_IFS="${NEWLINE}${SEP}"

# We should be able to make an image for other architectures, but the
# default should be this machine's. Use this variable for that.
: "${ARCH:=$(arch)}"

# If --compress option isn't given, COMPRESS wouldn't be set, but it
# should be set to none in that case.
: "${COMPRESS:=none}"

# If kernel.args is empty, vbutil_kernel returns an error. We can
# use "--" instead of putting a newline or a space into the cmdline.
: "${CMDLINE:=--}"

# We can optionally enable a size check from the environment variable,
# but let's keep it disabled by default.
: "${DEPTHCHARGE_MAX_SIZE:=0}"

# These are distro-specific paths for necessary files.
: "${VBOOT_DEVKEYS:=/usr/share/vboot/devkeys}"
: "${VBOOT_KEYBLOCK:=${VBOOT_DEVKEYS}/kernel.keyblock}"
: "${VBOOT_SIGNPUBKEY:=${VBOOT_DEVKEYS}/kernel_subkey.vbpubk}"
: "${VBOOT_SIGNPRIVATE:=${VBOOT_DEVKEYS}/kernel_data_key.vbprivk}"

# Import common functions
. "lib/msg.sh"

parse_args() {
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -h|--help)
                print_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=yes
                shift
                ;;
            -o|--output)
                OUTPUT="$2"
                shift 2
                ;;
            -C|--compress)
                COMPRESS="$2"
                shift 2
                ;;
            -n|--description)
                DESCRIPTION="$2"
                shift 2
                ;;
            -c|--cmdline)
                CMDLINE="${CMDLINE} $2"
                CMDLINE="${CMDLINE# }"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                usage_error "Option '$1' not understood."
                ;;
            *)
                break
                ;;
        esac
    done

    while [ "$#" -gt 0 ]; do
        case "$1" in
            -*)
                usage_error "Options must precede input filenames."
                ;;
            *dtb*)
                DTBS="${DTBS}${SEP}$1"
                DTBS="${DTBS#${SEP}}"
                shift
                ;;
            *initrd*|*initramfs*|*cpio*)
                INITRAMFS="$1"
                shift
                ;;
            *vmlinuz*|*vmlinux*|*linux*|*Image*)
                VMLINUZ="$1"
                shift
                ;;
            *)
                if [ -z "$VMLINUZ" ]; then
                    VMLINUZ="$1"
                    shift
                elif [ -z "$INITRAMFS" ]; then
                    INITRAMFS="$1"
                    shift
                else
                    DTBS="${DTBS}${SEP}$1"
                    DTBS="${DTBS#${SEP}}"
                    shift
                fi
                ;;
        esac
    done

    if [ -z "$OUTPUT" ]; then
        usage_error "Output argument is mandatory."
    fi
}

validate_inputs() {
    if [ -z "$VMLINUZ" ]; then
        usage_error "Input file vmlinuz is required."
    elif [ ! -r "$VMLINUZ" ]; then
        error "File '$VMLINUZ' (vmlinuz) not found or is not readable."
    else
        info "Using vmlinuz: '$VMLINUZ'"
    fi

    if [ -n "$INITRAMFS" ]; then
        if [ ! -r "$INITRAMFS" ]; then
            error "File '$INITRAMFS' (initramfs) not found or is not readable."
        else
            info "Using initramfs: '$INITRAMFS'"
        fi
    fi

    IFS="$CUSTOM_IFS"
    for DTB in $DTBS; do
        if [ ! -r "$DTB" ]; then
            error "File '$DTB' (dtb) not found or is not readable."
        else
            info "Using dtb: '$DTB'"
        fi
    done
    IFS="$ORIG_IFS"
}

set_mkimage_arch() {
    if [ -z "$MKIMAGE_ARCH" ]; then
        case "$ARCH" in
            arm64|aarch64) MKIMAGE_ARCH=arm64 ;;
            arm*)          MKIMAGE_ARCH=arm ;;
            amd64|x86_64)  MKIMAGE_ARCH=x86_64 ;;
            x86|i386)      MKIMAGE_ARCH=x86 ;;
            *) error "Architecture '$ARCH' is not supported." ;;
        esac
    fi
}

set_vboot_arch() {
    if [ -z "$VBOOT_ARCH" ]; then
        case "$ARCH" in
            arm64|aarch64) VBOOT_ARCH=aarch64 ;;
            arm*)          VBOOT_ARCH=arm ;;
            amd64|x86_64)  VBOOT_ARCH=amd64 ;;
            x86|i386)      VBOOT_ARCH=x86 ;;
            *) error "Architecture '$ARCH' is not supported." ;;
        esac
    fi
}

# Some steps will require a directory to write temporary files. But
# let's also allow those files to be redirected somewhere else.
setup_tmp_dir() {
    tmp="$(mktemp -td mkdepthcharge.XXXXXXXX)"
    trap 'rm -rf "${tmp}"' EXIT

    : "${TMP_VMLINUZ:=${tmp}/vmlinuz}"
    : "${TMP_VMLINUZ_LZ4:=${tmp}/vmlinuz.lz4}"
    : "${TMP_VMLINUZ_LZMA:=${tmp}/vmlinuz.lzma}"
    : "${TMP_VMLINUZ_GUNZIPPED:=${tmp}/vmlinuz-gunzipped}"
    : "${TMP_INITRAMFS:=${tmp}/initrd.img}"
    : "${TMP_DTBS_DIR:=${tmp}/dtbs}"
    : "${TMP_CMDLINE:=${tmp}/kernel.args}"
    : "${TMP_BOOTSTUB:=${tmp}/bootstub.bin}"
    : "${TMP_FIT_IMAGE:=${tmp}/depthcharge.itb}"
    : "${TMP_DEPTHCHARGE_IMAGE:=${tmp}/depthcharge.img}"

    mkdir -p "$TMP_DTBS_DIR"
}

# Decompress kernel if packaged as gzip compressed.
decompress_kernel() {
    if { command -v gzip && gzip -t "$VMLINUZ"; } >/dev/null 2>&1; then
        info "Kernel is gzip compressed, decompressing."
        gzip -d <"$VMLINUZ" >"$TMP_VMLINUZ_GUNZIPPED"
        VMLINUZ="$TMP_VMLINUZ_GUNZIPPED"
    fi
}

compress_kernel() {
    if [ "$VMLINUZ" = "$TMP_VMLINUZ_LZ4" ]; then
        error "Not compressing kernel twice (lz4 then '$COMPRESS')."
    elif [ "$VMLINUZ" = "$TMP_VMLINUZ_LZMA" ]; then
        error "Not compressing kernel twice (lzma then '$COMPRESS')."
    fi

    case "$COMPRESS" in
        lz4)
            info "Compressing kernel with lz4."
            lz4 -z -9 <"$VMLINUZ" >"$TMP_VMLINUZ_LZ4"
            VMLINUZ="$TMP_VMLINUZ_LZ4"
            ;;
        lzma)
            info "Compressing kernel with lzma."
            lzma -z <"$VMLINUZ" >"$TMP_VMLINUZ_LZMA"
            VMLINUZ="$TMP_VMLINUZ_LZMA"
            ;;
        none)
            : # No need to do anything.
            ;;
        *)
            error "Compression type '$COMPRESS' is not supported." \
                    "Valid values are: none, lz4, lzma."
            ;;
    esac
}

# mkimage can't open files when they are read-only for some reason.
# We'll copy them into a temp dir in fear of modifying the originals.
copy_inputs_to_tmp() {
    cp "$VMLINUZ" "$TMP_VMLINUZ"
    VMLINUZ="$TMP_VMLINUZ"

    if [ -n "$INITRAMFS" ]; then
        cp "$INITRAMFS" "$TMP_INITRAMFS"
        INITRAMFS="$TMP_INITRAMFS"
    fi

    IFS="$CUSTOM_IFS"
    if [ -n "$DTBS" ]; then
        cp -t "$TMP_DTBS_DIR" -- $DTBS
        DTBS="$(find "$TMP_DTBS_DIR" -type f)"
    fi
    IFS="$ORIG_IFS"
}

# Somehow mkimage needs write permissions, we can add them after we copy
# the files to a temporary directory.
make_inputs_writable() {
    if [ ! -w "$VMLINUZ" ]; then
        chmod +w "$VMLINUZ"
    fi

    if [ -n "$INITRAMFS" ] && [ ! -w "$INITRAMFS" ]; then
        chmod +w "$INITRAMFS"
    fi

    IFS="$CUSTOM_IFS"
    for DTB in $DTBS; do
        if [ ! -w "$DTB" ]; then
            chmod +w "$DTB"
        fi
    done
    IFS="$ORIG_IFS"
}

make_cmdline_file() {
    if [ -z "$VBOOT_CMDLINE" ]; then
        echo -n $CMDLINE >"$TMP_CMDLINE"
        VBOOT_CMDLINE="$TMP_CMDLINE"
    fi
}

make_bootstub_file() {
    if [ -z "$BOOTSTUB" ]; then
        case "$VBOOT_ARCH" in
            arm*|aarch64)
                info "Using dummy file for bootloader."
                dd if=/dev/zero of="$TMP_BOOTSTUB" \
                    count=1 bs=512 status=none
                BOOTSTUB="$TMP_BOOTSTUB"
                ;;
            x86|amd64|*)
                error "Architecture '$VBOOT_ARCH' needs a bootstub binary."
                ;;
        esac
    fi
}

pack_fit() {
    IFS="$CUSTOM_IFS"
    if [ -z "$FIT_IMAGE" ]; then
        if [ -n "$INITRAMFS" ]; then
            MKIMAGE_INITRAMFS_ARGS="-i${SEP}${INITRAMFS}"
        fi
        if [ -n "$DTBS" ]; then
            MKIMAGE_DTB_ARGS="$(printf -- "-b${SEP}%s${SEP}" $DTBS)"
        fi
        info "Running mkimage:"
        mkimage \
            -f auto \
            -A "$MKIMAGE_ARCH" \
            -O linux \
            -C "$COMPRESS" \
            -n "$DESCRIPTION" \
            -d "$VMLINUZ" \
            $MKIMAGE_INITRAMFS_ARGS \
            $MKIMAGE_DTB_ARGS \
            "$TMP_FIT_IMAGE" \
            || error "Could not pack inputs into a FIT image."
        FIT_IMAGE="$TMP_FIT_IMAGE"
    fi
    IFS="$ORIG_IFS"
}

pack_depthcharge() {
    if [ -z "$DEPTHCHARGE_IMAGE" ]; then
        info "Running vbutil_kernel (pack):"
        futility vbutil_kernel \
            --version 1 \
            --arch "$VBOOT_ARCH" \
            --vmlinuz "$FIT_IMAGE" \
            --config "$VBOOT_CMDLINE" \
            --bootloader "$BOOTSTUB" \
            --keyblock "$VBOOT_KEYBLOCK" \
            --signprivate "$VBOOT_SIGNPRIVATE" \
            --pack "$TMP_DEPTHCHARGE_IMAGE" \
            || error "Could not pack inputs into a depthcharge image."
        DEPTHCHARGE_IMAGE="$TMP_DEPTHCHARGE_IMAGE"
    fi
}

verify_depthcharge() {
    info "Running vbutil_kernel (verify):"
    futility vbutil_kernel \
        --signpubkey "$VBOOT_SIGNPUBKEY" \
        --verify "$DEPTHCHARGE_IMAGE" \
        || error "Generated image cannot be verified by vbutil_kernel."
}

check_depthcharge_size() {
    if [ "${DEPTHCHARGE_MAX_SIZE}" -gt 0 ]; then
        info "Checking if image fits into size limit."
        size="$(stat -c '%s' "$DEPTHCHARGE_IMAGE")"
        if [ "$size" -gt "${DEPTHCHARGE_MAX_SIZE}" ]; then
            error "Output image size too big to boot."
        fi
    fi
}

copy_depthcharge_to_output() {
    info "Copying image to output '$OUTPUT'."
    cp -f "$DEPTHCHARGE_IMAGE" "$OUTPUT" \
        || error "Couldn't copy to output."
}

main() {
    parse_args "$@"

    if [ "$VERBOSE" != yes ]; then
        exec >/dev/null
    fi

    validate_inputs
    set_mkimage_arch
    set_vboot_arch

    setup_tmp_dir
    copy_inputs_to_tmp
    decompress_kernel
    compress_kernel
    make_inputs_writable
    make_cmdline_file
    make_bootstub_file

    pack_fit
    pack_depthcharge

    verify_depthcharge
    check_depthcharge_size
    copy_depthcharge_to_output
}

main "$@"
