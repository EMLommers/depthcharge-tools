#!/bin/sh
set -e

usage() {
cat <<EOF
Usage:
 mkdepthcharge [options] -o FILE [--] vmlinuz [initramfs] [dtb ...]

Build boot images for the ChromeOS firmware.

Options:
 -h, --help                 Show this help message.
 -v, --verbose              Print more detailed output.
 -o, --output FILE          Write resulting image to FILE.

FIT image options:
 -A, --arch ARCH            Architecture to build for (prefers -A).
 -C, --compress TYPE        Compress vmlinuz with lz4 or lzma.
 -n, --description DESC     Description of vmlinuz to put in the FIT.

Depthcharge image options:
 -A, --arch ARCH            Architecture to build for (prefers --arch).
 -c, --cmdline CMD          Command-line parameters for the kernel.
                            be used multiple times to append new values.
     --bootloader FILE      Bootloader stub binary to use.
     --keyblock FILE        The key block file (.keyblock).
     --signprivate FILE     Private key (.vbprivk) to sign the image.
     --signpubkey FILE      Public key (.vbpubk) to verify the image.
     --max-size SIZE        Fail if image is bigger than SIZE bytes.
EOF
}

. "lib/msg.sh"
. "lib/tmp.sh"
. "lib/ifs.sh"

# Use custom IFS so we can support paths with spaces, $(find ...), etc.
IFS="$CUSTOM_IFS"


# Set argument defaults
# ---------------------

# Verbosity options.
: "${VERBOSE:=no}"
: "${QUIET:=no}"
: "${SILENT:=no}"

# We should be able to make an image for other architectures, but the
# default should be this machine's. Use this variable for that.
: "${ARCH:=$(arch)}"
: "${ARCH:=unknown}"

# If --compress option isn't given, COMPRESS wouldn't be set, but it
# should be set to none in that case.
: "${COMPRESS:=none}"

# If kernel.args is empty, vbutil_kernel returns an error. We can
# use "--" instead of putting a newline or a space into the cmdline.
: "${CMDLINE:=--}"

# We can optionally enable a size check from the environment variable,
# but let's keep it disabled by default.
: "${MAX_SIZE:=0}"

# These are distro-specific paths for necessary files.
: "${VBOOT_DEVKEYS:=/usr/share/vboot/devkeys}"
: "${VBOOT_KEYBLOCK:=${VBOOT_DEVKEYS}/kernel.keyblock}"
: "${VBOOT_SIGNPUBKEY:=${VBOOT_DEVKEYS}/kernel_subkey.vbpubk}"
: "${VBOOT_SIGNPRIVATE:=${VBOOT_DEVKEYS}/kernel_data_key.vbprivk}"


# Parse options and arguments
# ---------------------------

set_mkimage_arch() {
    if [ -n "${1:-}" ] && [ -z "${VBOOT_ARCH:-}" ]; then
        ARCH="$1"
    fi

    case "${1:-${MKIMAGE_ARCH:-$ARCH}}" in
        arm64|aarch64)  MKIMAGE_ARCH=arm64 ;;
        arm*)           MKIMAGE_ARCH=arm ;;
        amd64|x86_64)   MKIMAGE_ARCH=x86_64 ;;
        x86|i386)       MKIMAGE_ARCH=x86 ;;
        *) error "Architecture '$1' is not supported for mkimage." ;;
    esac
}

set_vboot_arch() {
    if [ -n "${1:-}" ] && [ -z "${MKIMAGE_ARCH:-}" ]; then
        ARCH="$1"
    fi

    case "${1:-${VBOOT_ARCH:-$ARCH}}" in
        arm64|aarch64)  VBOOT_ARCH=aarch64 ;;
        arm*)           VBOOT_ARCH=arm ;;
        amd64|x86_64)   VBOOT_ARCH=amd64 ;;
        x86|i386)       VBOOT_ARCH=x86 ;;
        *) error "Architecture '$1' is not supported for vbutil_kernel." ;;
    esac
}

add_cmdline() {
    if has_newline "$1"; then
        error "Can't have newlines in cmdline '$1'."
    else
        CMDLINE="${CMDLINE:-}${CMDLINE:+$NEWLINE}${1}"
    fi
}

set_vmlinuz() {
    if [ -n "${VMLINUZ:-}" ]; then
        error "Can't have vmlinuz multiple times ('$VMLINUZ', '$1')."
    else
        VMLINUZ="$1"
    fi
}

set_initramfs() {
    if [ -n "${INITRAMFS:-}" ]; then
        error "Can't have vmlinuz multiple times ('$INITRAMFS', '$1')."
    else
        INITRAMFS="$1"
    fi
}

add_dtb() {
    DTBS="${DTBS:-}${DTBS:+$NEWLINE}${1}"
}

file_arg() {
    if [ ! -r "$1" ]; then
        error "File input '$1' is not found or not readable."
    fi

    if has_newline "$1"; then
        error "Can't have newlines in input filename '$1'."
    fi

    # mkimage can't open files when they are read-only for some reason.
    # Copy them into a temp dir in fear of modifying the originals.
    # We can add write permissions after we copy the files to temp.
    temp=$(temp_copy "$1")
    chmod +w "$temp"

    case "$(basename "$1")" in
        # Try some heuristics first.
        *dtb*)
            info "Using dtb: '$1'"
            add_dtb "$temp"
            ;;
        *initrd*|*initramfs*|*cpio*)
            info "Using initramfs: '$1'"
            set_initramfs "$temp"
            ;;
        *vmlinuz*|*vmlinux*|*linux*|*Image*)
            info "Using vmlinuz: '$1'"
            set_vmlinuz "$temp"
            ;;

        # Assume in the order given in usage.
        *)  if set_vmlinuz "$temp" 2>/dev/null; then
                info "Using vmlinuz: '$1'"
            elif set_initramfs "$temp" 2>/dev/null; then
                info "Using initramfs: '$1'"
            elif add_dtb "$temp" 2>/dev/null; then
                info "Using dtb: '$1'"
            else
                error "Couldn't parse file argument '$1'."
            fi
            ;;
    esac
}

# Check verbose options before printing anything.
for arg in "$@"; do
    case "$arg" in
        -v|--verbose) VERBOSE=yes ;;
        --) break ;;
    esac
done

while [ "$#" -gt 0 ]; do
    case "$1" in
        # Options:
        -h|--help)          usage;                      exit 0 ;;
        -v|--verbose)       VERBOSE=yes;                shift 1 ;;
        -o|--output)        OUTPUT="$2";                shift 2 ;;

        # FIT image options:
        -A)                 set_mkimage_arch "$2";      shift 2 ;;
        -C|--compress)      COMPRESS="$2";              shift 2 ;;
        -n|--description)   DESCRIPTION="$2";           shift 2 ;;

        # Depthcharge options:
        --arch)             set_vboot_arch "$2";        shift 2 ;;
        -c|--cmdline)       add_cmdline "$2";           shift 2 ;;
        --bootloader)       VBOOT_BOOTSTUB="$2";        shift 2 ;;
        --keyblock)         VBOOT_KEYBLOCK="$2";        shift 2 ;;
        --signpubkey)       VBOOT_SIGNPUBKEY="$2";      shift 2 ;;
        --signprivate)      VBOOT_SIGNPRIVATE="$2";     shift 2 ;;
        --max-size)         MAX_SIZE="$2";              shift 2 ;;

        # End of options
        --) shift; break ;;
        -*) usage_error "Option '$1' not understood." ;;
        *)  file_arg "$1"; shift ;;
    esac
done

# Assume arguments after "--" are files.
while [ "$#" -gt 0 ]; do
    file_arg "$1"
    shift
done

# Synchronize -A and --arch if only one is given, or set to defaults.
set_mkimage_arch
set_vboot_arch

if [ -z "$VMLINUZ" ]; then
    usage_error "Input file vmlinuz is required."
fi

if [ -z "$OUTPUT" ]; then
    usage_error "Output argument is mandatory."
fi


# Prepare vmlinuz
# ---------------

# Decompress kernel if packaged as gzip compressed.
if { command -v gzip && gzip -t "$VMLINUZ"; } >/dev/null 2>&1; then
    temp="$(temp_file vmlinuz-gunzip)"
    info "Kernel is gzip compressed, decompressing."
    gzip -d <"$VMLINUZ" >"$temp"
    VMLINUZ="$temp"
    unset temp
fi

case "$COMPRESS" in
    lz4)
        info "Compressing kernel with lz4."
        temp="$(temp_file vmlinuz.lz4)"
        lz4 -z -9 <"$VMLINUZ" >"$temp"
        VMLINUZ="$temp"
        unset temp
        ;;
    lzma)
        info "Compressing kernel with lzma."
        temp="$(temp_file vmlinuz.lzma)"
        lzma -z <"$VMLINUZ" >"$temp"
        VMLINUZ="$temp"
        unset temp
        ;;
    none)
        : # No need to do anything.
        ;;
    *)
        error "Compression type '$COMPRESS' is not supported." \
                "Valid values are: none, lz4, lzma."
        ;;
esac


# Prepare additional files
# ------------------------

# vbutil_kernel --config argument and wants cmdline as a file.
temp="$(temp_file kernel.args)"
echo -n $CMDLINE >"$temp"
VBOOT_CMDLINE="$temp"
unset temp

# vbutil_kernel --bootloader argument wants a bootstub binary, but it's
# contents don't matter on arm systems.
if [ -z "$VBOOT_BOOTSTUB" ]; then
    case "$VBOOT_ARCH" in
        arm*|aarch64)
            info "Using dummy file for bootloader."
            temp="$(temp_file bootstub)"
            dd if=/dev/zero of="$temp" count=1 bs=512 status=none
            VBOOT_BOOTSTUB="$temp"
            unset temp
            ;;
        x86|amd64|*)
            error "Architecture '$VBOOT_ARCH' needs a bootstub binary."
            ;;
    esac
fi


# Make FIT image
# --------------

temp="$(temp_file depthcharge.itb)"
info "Running mkimage:"
(
    set --

    if [ -n "${DTBS:-}" ]; then
        for dtb in $DTBS; do
            set -- "$@" "-b" "$dtb"
        done
    fi

    if [ -n "${INITRAMFS:-}" ]; then
        set -- "-i" "$INITRAMFS" "$@"
    fi

    mkimage \
        -f auto \
        -A "$MKIMAGE_ARCH" \
        -O linux \
        -C "$COMPRESS" \
        -n "$DESCRIPTION" \
        -d "$VMLINUZ" \
        "$@" \
        "$temp"
) || error "Could not pack inputs into a FIT image."
FIT_IMAGE="$temp"


# Make depthcharge image
# ----------------------

info "Running vbutil_kernel (pack):"
temp="$(temp_file depthcharge.img)"
futility vbutil_kernel \
    --version 1 \
    --arch "$VBOOT_ARCH" \
    --vmlinuz "$FIT_IMAGE" \
    --config "$VBOOT_CMDLINE" \
    --bootloader "$VBOOT_BOOTSTUB" \
    --keyblock "$VBOOT_KEYBLOCK" \
    --signprivate "$VBOOT_SIGNPRIVATE" \
    --pack "$temp" \
    || error "Could not pack inputs into a depthcharge image."
DEPTHCHARGE_IMAGE="$temp"

info "Running vbutil_kernel (verify):"
futility vbutil_kernel \
    --signpubkey "$VBOOT_SIGNPUBKEY" \
    --verify "$DEPTHCHARGE_IMAGE" \
    || error "Generated image cannot be verified by vbutil_kernel."

if [ "${MAX_SIZE}" -gt 0 ]; then
    info "Checking if image fits into size limit."
    size="$(stat -c '%s' "$DEPTHCHARGE_IMAGE")"
    if [ "$size" -gt "${MAX_SIZE}" ]; then
        error "Output image size too big to boot."
    fi
fi

info "Copying image to output '$OUTPUT'."
cp -f "$DEPTHCHARGE_IMAGE" "$OUTPUT" \
    || error "Couldn't copy to output."
