#!/bin/sh
set -e

usage() {
cat <<EOF
Usage: mkdepthcharge [options] -o FILE [--] vmlinuz [initrd] [dtb ...]

Options:
 -h, --help              Show this help message.
 -v, --verbose           Print more detailed output.
 -o, --output FILE       Write resulting image to FILE.
 -c, --cmdline CMD       Command-line parameters for the kernel. Can
                         be used multiple times to append new values.
 -C, --compress TYPE     Compress kernel with one of: none, lz4, lzma.
 -n, --description DESC  Description to use as a mkimage argument.
EOF
}

# We should be able to make an image for other architectures, but the
# default should be this machine's. Use this variable for that.
: "${ARCH:=$(arch)}"

# If --compress option isn't given, COMPRESS wouldn't be set, but it
# should be set to none in that case.
: "${COMPRESS:=none}"

# If kernel.args is empty, vbutil_kernel returns an error. We can
# use "--" instead of putting a newline or a space into the cmdline.
: "${CMDLINE:=--}"

# We can optionally enable a size check from the environment variable,
# but let's keep it disabled by default.
: "${DEPTHCHARGE_MAX_SIZE:=0}"

# These are distro-specific paths for necessary files.
: "${VBOOT_DEVKEYS:=/usr/share/vboot/devkeys}"
: "${VBOOT_KEYBLOCK:=${VBOOT_DEVKEYS}/kernel.keyblock}"
: "${VBOOT_SIGNPUBKEY:=${VBOOT_DEVKEYS}/kernel_subkey.vbpubk}"
: "${VBOOT_SIGNPRIVATE:=${VBOOT_DEVKEYS}/kernel_data_key.vbprivk}"

# Import common functions
. "lib/msg.sh"
. "lib/tmp.sh"
. "lib/ifs.sh"

# Use custom IFS so we can support paths with spaces, $(find ...), etc.
IFS="$CUSTOM_IFS"

parse_args() {
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -h|--help)
                print_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=yes
                shift
                ;;
            -o|--output)
                OUTPUT="$2"
                shift 2
                ;;
            -C|--compress)
                COMPRESS="$2"
                shift 2
                ;;
            -n|--description)
                DESCRIPTION="$2"
                shift 2
                ;;
            -c|--cmdline)
                CMDLINE="${CMDLINE:-}${CMDLINE:+$NEWLINE}${1}"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                usage_error "Option '$1' not understood."
                ;;
            *)
                break
                ;;
        esac
    done

    while [ "$#" -gt 0 ]; do
        case "$1" in
            -*)
                usage_error "Options must precede input filenames."
                ;;
            *dtb*)
                DTBS="${DTBS:-}${DTBS:+$NEWLINE}${1}"
                shift
                ;;
            *initrd*|*initramfs*|*cpio*)
                INITRAMFS="$1"
                shift
                ;;
            *vmlinuz*|*vmlinux*|*linux*|*Image*)
                VMLINUZ="$1"
                shift
                ;;
            *)
                if [ -z "$VMLINUZ" ]; then
                    VMLINUZ="$1"
                    shift
                elif [ -z "$INITRAMFS" ]; then
                    INITRAMFS="$1"
                    shift
                else
                    DTBS="${DTBS:-}${DTBS:+$NEWLINE}${1}"
                    shift
                fi
                ;;
        esac
    done

    if [ -z "$OUTPUT" ]; then
        usage_error "Output argument is mandatory."
    fi
}

validate_inputs() {
    if [ -z "$VMLINUZ" ]; then
        usage_error "Input file vmlinuz is required."
    elif [ ! -r "$VMLINUZ" ]; then
        error "File '$VMLINUZ' (vmlinuz) not found or is not readable."
    else
        info "Using vmlinuz: '$VMLINUZ'"
    fi

    if [ -n "$INITRAMFS" ]; then
        if [ ! -r "$INITRAMFS" ]; then
            error "File '$INITRAMFS' (initramfs) not found or is not readable."
        else
            info "Using initramfs: '$INITRAMFS'"
        fi
    fi

    for DTB in $DTBS; do
        if [ ! -r "$DTB" ]; then
            error "File '$DTB' (dtb) not found or is not readable."
        else
            info "Using dtb: '$DTB'"
        fi
    done
}

set_mkimage_arch() {
    if [ -z "$MKIMAGE_ARCH" ]; then
        case "$ARCH" in
            arm64|aarch64) MKIMAGE_ARCH=arm64 ;;
            arm*)          MKIMAGE_ARCH=arm ;;
            amd64|x86_64)  MKIMAGE_ARCH=x86_64 ;;
            x86|i386)      MKIMAGE_ARCH=x86 ;;
            *) error "Architecture '$ARCH' is not supported." ;;
        esac
    fi
}

set_vboot_arch() {
    if [ -z "$VBOOT_ARCH" ]; then
        case "$ARCH" in
            arm64|aarch64) VBOOT_ARCH=aarch64 ;;
            arm*)          VBOOT_ARCH=arm ;;
            amd64|x86_64)  VBOOT_ARCH=amd64 ;;
            x86|i386)      VBOOT_ARCH=x86 ;;
            *) error "Architecture '$ARCH' is not supported." ;;
        esac
    fi
}

# Decompress kernel if packaged as gzip compressed.
decompress_kernel() {
    if { command -v gzip && gzip -t "$VMLINUZ"; } >/dev/null 2>&1; then
        temp="$(temp_file vmlinuz-gunzip)"
        info "Kernel is gzip compressed, decompressing."
        gzip -d <"$VMLINUZ" >"$temp"
        VMLINUZ="$temp"
        unset temp
    fi
}

compress_kernel() {
    case "$COMPRESS" in
        lz4)
            info "Compressing kernel with lz4."
            temp="$(temp_file vmlinuz.lz4)"
            lz4 -z -9 <"$VMLINUZ" >"$temp"
            VMLINUZ="$temp"
            unset temp
            ;;
        lzma)
            info "Compressing kernel with lzma."
            temp="$(temp_file vmlinuz.lzma)"
            lzma -z <"$VMLINUZ" >"$temp"
            VMLINUZ="$temp"
            unset temp
            ;;
        none)
            : # No need to do anything.
            ;;
        *)
            error "Compression type '$COMPRESS' is not supported." \
                    "Valid values are: none, lz4, lzma."
            ;;
    esac
}

# mkimage can't open files when they are read-only for some reason.
# We'll copy them into a temp dir in fear of modifying the originals.
copy_inputs_to_tmp() {
    VMLINUZ="$(temp_copy "$VMLINUZ")"

    if [ -n "$INITRAMFS" ]; then
        INITRAMFS="$(temp_copy "$INITRAMFS")"
    fi

    if [ -n "$DTBS" ]; then
        temp="$(temp_dir dtbs)"
        cp -t "$temp" -- $DTBS
        DTBS="$(find "$temp" -type f)"
        unset temp
    fi
}

# Somehow mkimage needs write permissions, we can add them after we copy
# the files to a temporary directory.
make_inputs_writable() {
    if [ ! -w "$VMLINUZ" ]; then
        chmod +w "$VMLINUZ"
    fi

    if [ -n "$INITRAMFS" ] && [ ! -w "$INITRAMFS" ]; then
        chmod +w "$INITRAMFS"
    fi

    for DTB in $DTBS; do
        if [ ! -w "$DTB" ]; then
            chmod +w "$DTB"
        fi
    done
}

make_cmdline_file() {
    if [ -z "$VBOOT_CMDLINE" ]; then
        temp="$(temp_file kernel.args)"
        echo -n $CMDLINE >"$temp"
        VBOOT_CMDLINE="$temp"
        unset temp
    fi
}

make_bootstub_file() {
    if [ -z "$BOOTSTUB" ]; then
        case "$VBOOT_ARCH" in
            arm*|aarch64)
                info "Using dummy file for bootloader."
                temp="$(temp_file bootstub)"
                dd if=/dev/zero of="$temp" count=1 bs=512 status=none
                BOOTSTUB="$temp"
                unset temp
                ;;
            x86|amd64|*)
                error "Architecture '$VBOOT_ARCH' needs a bootstub binary."
                ;;
        esac
    fi
}

pack_fit() {
    if [ -z "$FIT_IMAGE" ]; then
        temp="$(temp_file depthcharge.itb)"
        info "Running mkimage:"
        (
            set --

            if [ -n "${DTBS:-}" ]; then
                for dtb in $DTBS; do
                    set -- "$@" "-b" "$dtb"
                done
            fi

            if [ -n "${INITRAMFS:-}" ]; then
                set -- "-i" "$INITRAMFS" "$@"
            fi

            mkimage \
                -f auto \
                -A "$MKIMAGE_ARCH" \
                -O linux \
                -C "$COMPRESS" \
                -n "$DESCRIPTION" \
                -d "$VMLINUZ" \
                "$@" \
                "$temp"
        ) || error "Could not pack inputs into a FIT image."
        FIT_IMAGE="$temp"
    fi
}

pack_depthcharge() {
    if [ -z "$DEPTHCHARGE_IMAGE" ]; then
        info "Running vbutil_kernel (pack):"
        temp="$(temp_file depthcharge.img)"
        futility vbutil_kernel \
            --version 1 \
            --arch "$VBOOT_ARCH" \
            --vmlinuz "$FIT_IMAGE" \
            --config "$VBOOT_CMDLINE" \
            --bootloader "$BOOTSTUB" \
            --keyblock "$VBOOT_KEYBLOCK" \
            --signprivate "$VBOOT_SIGNPRIVATE" \
            --pack "$temp" \
            || error "Could not pack inputs into a depthcharge image."
        DEPTHCHARGE_IMAGE="$temp"
    fi
}

verify_depthcharge() {
    info "Running vbutil_kernel (verify):"
    futility vbutil_kernel \
        --signpubkey "$VBOOT_SIGNPUBKEY" \
        --verify "$DEPTHCHARGE_IMAGE" \
        || error "Generated image cannot be verified by vbutil_kernel."
}

check_depthcharge_size() {
    if [ "${DEPTHCHARGE_MAX_SIZE}" -gt 0 ]; then
        info "Checking if image fits into size limit."
        size="$(stat -c '%s' "$DEPTHCHARGE_IMAGE")"
        if [ "$size" -gt "${DEPTHCHARGE_MAX_SIZE}" ]; then
            error "Output image size too big to boot."
        fi
    fi
}

copy_depthcharge_to_output() {
    info "Copying image to output '$OUTPUT'."
    cp -f "$DEPTHCHARGE_IMAGE" "$OUTPUT" \
        || error "Couldn't copy to output."
}

main() {
    parse_args "$@"

    if [ "$VERBOSE" != yes ]; then
        exec >/dev/null
    fi

    validate_inputs
    set_mkimage_arch
    set_vboot_arch

    copy_inputs_to_tmp
    decompress_kernel
    compress_kernel
    make_inputs_writable
    make_cmdline_file
    make_bootstub_file

    pack_fit
    pack_depthcharge

    verify_depthcharge
    check_depthcharge_size
    copy_depthcharge_to_output
}

main "$@"
