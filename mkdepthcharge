#!/bin/sh
set -e

usage() {
cat <<EOF
Usage: mkdepthcharge [options] -o FILE [--] vmlinuz [initrd] [dtb ...]

Options:
 -h, --help              Show this help message.
 -v, --verbose           Print more detailed output.
 -o, --output FILE       Write resulting image to FILE.
 -c, --cmdline CMD       Command-line parameters for the kernel. Can
                         be used multiple times to append new values.
 -C, --compress TYPE     Compress kernel with one of: none, lz4, lzma.
 -n, --description DESC  Description to use as a mkimage argument.
EOF
}

# We should be able to make an image for other architectures, but the
# default should be this machine's. Use this variable for that.
: "${ARCH:=$(arch)}"

# If --compress option isn't given, COMPRESS wouldn't be set, but it
# should be set to none in that case.
: "${COMPRESS:=none}"

# If kernel.args is empty, vbutil_kernel returns an error. We can
# use "--" instead of putting a newline or a space into the cmdline.
: "${CMDLINE:=--}"

# We can optionally enable a size check from the environment variable,
# but let's keep it disabled by default.
: "${DEPTHCHARGE_MAX_SIZE:=0}"

# These are distro-specific paths for necessary files.
: "${VBOOT_DEVKEYS:=/usr/share/vboot/devkeys}"
: "${VBOOT_KEYBLOCK:=${VBOOT_DEVKEYS}/kernel.keyblock}"
: "${VBOOT_SIGNPUBKEY:=${VBOOT_DEVKEYS}/kernel_subkey.vbpubk}"
: "${VBOOT_SIGNPRIVATE:=${VBOOT_DEVKEYS}/kernel_data_key.vbprivk}"

# Import common functions
. "lib/msg.sh"
. "lib/tmp.sh"
. "lib/ifs.sh"

# Use custom IFS so we can support paths with spaces, $(find ...), etc.
IFS="$CUSTOM_IFS"


# Parse options and arguments
# ---------------------------

add_cmdline() {
    if has_newline "$1"; then
        error "Can't have newlines in cmdline '$1'."
    else
        CMDLINE="${CMDLINE:-}${CMDLINE:+$NEWLINE}${1}"
    fi
}

set_vmlinuz() {
    if [ -n "${VMLINUZ:-}" ]; then
        error "Can't have vmlinuz multiple times ('$VMLINUZ', '$1')."
    else
        VMLINUZ="$1"
    fi
}

set_initramfs() {
    if [ -n "${INITRAMFS:-}" ]; then
        error "Can't have vmlinuz multiple times ('$INITRAMFS', '$1')."
    else
        INITRAMFS="$1"
    fi
}

add_dtb() {
    DTBS="${DTBS:-}${DTBS:+$NEWLINE}${1}"
}

parse_args() {
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -h|--help)
                print_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=yes
                shift
                ;;
            -o|--output)
                OUTPUT="$2"
                shift 2
                ;;
            -C|--compress)
                COMPRESS="$2"
                shift 2
                ;;
            -n|--description)
                DESCRIPTION="$2"
                shift 2
                ;;
            -c|--cmdline)
                add_cmdline "$2"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                usage_error "Option '$1' not understood."
                ;;
            *)
                break
                ;;
        esac
    done

    for arg in "$@"; do
        case "$arg" in
            -*)
                usage_error "Options must precede input filenames."
                ;;
        esac
    done

    while [ "$#" -gt 0 ]; do
        if [ ! -r "$1" ]; then
            error "File input '$1' is not found or not readable."
        fi

        if has_newline "$1"; then
            error "Can't have newlines in input filename '$1'."
        fi

        # mkimage can't open files when they are read-only for some reason.
        # Copy them into a temp dir in fear of modifying the originals.
        # We can add write permissions after we copy the files to temp.
        temp=$(temp_copy "$1")
        chmod +w "$temp"

        case "$(basename "$1")" in
            # Try some heuristics first.
            *dtb*)
                info "Using dtb: '$1'"
                shift
                add_dtb "$temp"
                ;;
            *initrd*|*initramfs*|*cpio*)
                info "Using initramfs: '$1'"
                shift
                set_initramfs "$temp"
                ;;
            *vmlinuz*|*vmlinux*|*linux*|*Image*)
                info "Using vmlinuz: '$1'"
                shift
                set_vmlinuz "$temp"
                ;;

            # Assume in the order given in usage.
            *)  if set_vmlinuz "$temp" 2>/dev/null; then
                    info "Using vmlinuz: '$1'"
                    shift
                elif set_initramfs "$temp" 2>/dev/null; then
                    info "Using initramfs: '$1'"
                    shift
                elif add_dtb "$temp" 2>/dev/null; then
                    info "Using dtb: '$1'"
                    shift
                else
                    error "Couldn't parse file argument '$1'."
                fi
                ;;
        esac
    done

    if [ -z "$VMLINUZ" ]; then
        usage_error "Input file vmlinuz is required."
    fi

    if [ -z "$OUTPUT" ]; then
        usage_error "Output argument is mandatory."
    fi
}

set_mkimage_arch() {
    if [ -z "$MKIMAGE_ARCH" ]; then
        case "$ARCH" in
            arm64|aarch64) MKIMAGE_ARCH=arm64 ;;
            arm*)          MKIMAGE_ARCH=arm ;;
            amd64|x86_64)  MKIMAGE_ARCH=x86_64 ;;
            x86|i386)      MKIMAGE_ARCH=x86 ;;
            *) error "Architecture '$ARCH' is not supported." ;;
        esac
    fi
}

set_vboot_arch() {
    if [ -z "$VBOOT_ARCH" ]; then
        case "$ARCH" in
            arm64|aarch64) VBOOT_ARCH=aarch64 ;;
            arm*)          VBOOT_ARCH=arm ;;
            amd64|x86_64)  VBOOT_ARCH=amd64 ;;
            x86|i386)      VBOOT_ARCH=x86 ;;
            *) error "Architecture '$ARCH' is not supported." ;;
        esac
    fi
}

# Decompress kernel if packaged as gzip compressed.
decompress_kernel() {
    if { command -v gzip && gzip -t "$VMLINUZ"; } >/dev/null 2>&1; then
        temp="$(temp_file vmlinuz-gunzip)"
        info "Kernel is gzip compressed, decompressing."
        gzip -d <"$VMLINUZ" >"$temp"
        VMLINUZ="$temp"
        unset temp
    fi
}

compress_kernel() {
    case "$COMPRESS" in
        lz4)
            info "Compressing kernel with lz4."
            temp="$(temp_file vmlinuz.lz4)"
            lz4 -z -9 <"$VMLINUZ" >"$temp"
            VMLINUZ="$temp"
            unset temp
            ;;
        lzma)
            info "Compressing kernel with lzma."
            temp="$(temp_file vmlinuz.lzma)"
            lzma -z <"$VMLINUZ" >"$temp"
            VMLINUZ="$temp"
            unset temp
            ;;
        none)
            : # No need to do anything.
            ;;
        *)
            error "Compression type '$COMPRESS' is not supported." \
                    "Valid values are: none, lz4, lzma."
            ;;
    esac
}

make_cmdline_file() {
    if [ -z "$VBOOT_CMDLINE" ]; then
        temp="$(temp_file kernel.args)"
        echo -n $CMDLINE >"$temp"
        VBOOT_CMDLINE="$temp"
        unset temp
    fi
}

make_bootstub_file() {
    if [ -z "$BOOTSTUB" ]; then
        case "$VBOOT_ARCH" in
            arm*|aarch64)
                info "Using dummy file for bootloader."
                temp="$(temp_file bootstub)"
                dd if=/dev/zero of="$temp" count=1 bs=512 status=none
                BOOTSTUB="$temp"
                unset temp
                ;;
            x86|amd64|*)
                error "Architecture '$VBOOT_ARCH' needs a bootstub binary."
                ;;
        esac
    fi
}

pack_fit() {
    if [ -z "$FIT_IMAGE" ]; then
        temp="$(temp_file depthcharge.itb)"
        info "Running mkimage:"
        (
            set --

            if [ -n "${DTBS:-}" ]; then
                for dtb in $DTBS; do
                    set -- "$@" "-b" "$dtb"
                done
            fi

            if [ -n "${INITRAMFS:-}" ]; then
                set -- "-i" "$INITRAMFS" "$@"
            fi

            mkimage \
                -f auto \
                -A "$MKIMAGE_ARCH" \
                -O linux \
                -C "$COMPRESS" \
                -n "$DESCRIPTION" \
                -d "$VMLINUZ" \
                "$@" \
                "$temp"
        ) || error "Could not pack inputs into a FIT image."
        FIT_IMAGE="$temp"
    fi
}

pack_depthcharge() {
    if [ -z "$DEPTHCHARGE_IMAGE" ]; then
        info "Running vbutil_kernel (pack):"
        temp="$(temp_file depthcharge.img)"
        futility vbutil_kernel \
            --version 1 \
            --arch "$VBOOT_ARCH" \
            --vmlinuz "$FIT_IMAGE" \
            --config "$VBOOT_CMDLINE" \
            --bootloader "$BOOTSTUB" \
            --keyblock "$VBOOT_KEYBLOCK" \
            --signprivate "$VBOOT_SIGNPRIVATE" \
            --pack "$temp" \
            || error "Could not pack inputs into a depthcharge image."
        DEPTHCHARGE_IMAGE="$temp"
    fi
}

verify_depthcharge() {
    info "Running vbutil_kernel (verify):"
    futility vbutil_kernel \
        --signpubkey "$VBOOT_SIGNPUBKEY" \
        --verify "$DEPTHCHARGE_IMAGE" \
        || error "Generated image cannot be verified by vbutil_kernel."
}

check_depthcharge_size() {
    if [ "${DEPTHCHARGE_MAX_SIZE}" -gt 0 ]; then
        info "Checking if image fits into size limit."
        size="$(stat -c '%s' "$DEPTHCHARGE_IMAGE")"
        if [ "$size" -gt "${DEPTHCHARGE_MAX_SIZE}" ]; then
            error "Output image size too big to boot."
        fi
    fi
}

copy_depthcharge_to_output() {
    info "Copying image to output '$OUTPUT'."
    cp -f "$DEPTHCHARGE_IMAGE" "$OUTPUT" \
        || error "Couldn't copy to output."
}

main() {
    parse_args "$@"

    if [ "$VERBOSE" != yes ]; then
        exec >/dev/null
    fi

    set_mkimage_arch
    set_vboot_arch

    decompress_kernel
    compress_kernel
    make_cmdline_file
    make_bootstub_file

    pack_fit
    pack_depthcharge

    verify_depthcharge
    check_depthcharge_size
    copy_depthcharge_to_output
}

main "$@"
