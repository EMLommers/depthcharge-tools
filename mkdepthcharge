#!/bin/sh
set -eu

usage() {
cat <<EOF
Usage:
 mkdepthcharge [options] -o FILE [--] vmlinuz [initramfs] [dtb ...]

Build boot images for the ChromeOS firmware.

Options:
 -h, --help                 Show this help message.
 -v, --verbose              Print more detailed output.
 -o, --output FILE          Write resulting image to FILE.
 -A, --arch ARCH            Architecture to build for.
     --format FORMAT        Kernel image format to use: fit or zimage.

FIT image options:
 -C, --compress TYPE        Compress vmlinuz with lz4 or lzma.
 -n, --description DESC     Description of vmlinuz to put in the FIT.

Depthcharge image options:
 -c, --cmdline CMD          Command-line parameters for the kernel. Can
                            be used multiple times to append new values.
     --no-kern-guid         Don't prepend kern_guid=%U to the cmdline.
     --bootloader FILE      Bootloader stub binary to use.
     --devkeys DIR          Directory containing developer keys to use.
     --keyblock FILE        The key block file (.keyblock).
     --signprivate FILE     Private key (.vbprivk) to sign the image.
EOF
}

. "lib/msg.sh"
. "lib/tmp.sh"
. "lib/ifs.sh"


# Parse options and arguments
# ---------------------------

add_cmdline() {
    if has_newline "${1:-}"; then
        error "Can't have newlines in cmdline '$1'."
    elif [ -n "${1:-}" ]; then
        CMDLINE="${CMDLINE:-}${CMDLINE:+${NEWLINE}}${1}"
    fi
}

set_vmlinuz() {
    if [ -n "${VMLINUZ:-}" ]; then
        error "Can't have vmlinuz multiple times ('$VMLINUZ', '${1:-}')."
    elif [ -n "${1:-}" ]; then
        VMLINUZ="$1"
    fi
}

set_initramfs() {
    if [ -n "${INITRAMFS:-}" ]; then
        error "Can't have vmlinuz multiple times ('$INITRAMFS', '$1')."
    elif [ -n "${1:-}" ]; then
        INITRAMFS="$1"
    fi
}

add_dtb() {
    if [ -n "${1:-}" ]; then
        DTBS="${DTBS:-}${DTBS:+${NEWLINE}}${1}"
    fi
}

file_arg() {
    if [ ! -r "${1:-}" ]; then
        error "File input '${1:-}' is not found or not readable."
    fi

    if has_newline "$1"; then
        error "Can't have newlines in input filename '$1'."
    fi

    # mkimage can't open files when they are read-only for some reason.
    # Copy them into a temp dir in fear of modifying the originals.
    # We can add write permissions after we copy the files to temp.
    temp="$(temp_copy "$1")"
    chmod +w "$temp"

    case "$(basename "$1")" in
        # Try some heuristics first.
        *dtb*)
            info "Using dtb: '$1'"
            add_dtb "$temp"
            ;;
        *initrd*|*initramfs*|*cpio*)
            info "Using initramfs: '$1'"
            set_initramfs "$temp"
            ;;
        *vmlinuz*|*vmlinux*|*linux*|*Image*)
            info "Using vmlinuz: '$1'"
            set_vmlinuz "$temp"
            ;;

        # Assume in the order given in usage.
        *)  if set_vmlinuz "$temp" 2>/dev/null; then
                info "Using vmlinuz: '$1'"
            elif set_initramfs "$temp" 2>/dev/null; then
                info "Using initramfs: '$1'"
            elif add_dtb "$temp" 2>/dev/null; then
                info "Using dtb: '$1'"
            else
                error "Couldn't parse file argument '$1'."
            fi
            ;;
    esac
}

# Check verbose options before printing anything.
for arg in "$@"; do
    case "${arg:-}" in
        -v|--verbose) VERBOSE=yes ;;
        --) break ;;
    esac
done

while [ "$#" -gt 0 ]; do
    case "$1" in
        # Options:
        -h|--help)          usage;                      exit 0 ;;
        -v|--verbose)       VERBOSE=yes;                shift 1 ;;
        -o|--output)        OUTPUT="$2";                shift 2 ;;
        -A|--arch)          ARCH="$2";                  shift 2 ;;
        --format)           FORMAT="$2";                shift 2 ;;

        # FIT image options:
        -C|--compress)      COMPRESS="$2";              shift 2 ;;
        -n|--description)   DESCRIPTION="$2";           shift 2 ;;

        # Depthcharge options:
        -c|--cmdline)       add_cmdline "$2";           shift 2 ;;
        --no-kern-guid)     ADD_KERN_GUID=no;           shift 1 ;;
        --bootloader)       VBOOT_BOOTSTUB="$2";        shift 2 ;;
        --devkeys)          VBOOT_DEVKEYS="$2";         shift 2 ;;
        --keyblock)         VBOOT_KEYBLOCK="$2";        shift 2 ;;
        --signprivate)      VBOOT_SIGNPRIVATE="$2";     shift 2 ;;

        # End of options
        --) shift; break ;;
        -*) usage_error "Option '$1' not understood." ;;
        *)  file_arg "$1"; shift ;;
    esac
done

# Assume arguments after "--" are files.
while [ "$#" -gt 0 ]; do
    file_arg "$1"
    shift
done

# Check necessary options/arguments.
if [ -z "${VMLINUZ:-}" ]; then
    usage_error "Input file vmlinuz is required."
fi

if [ -z "${OUTPUT:-}" ]; then
    usage_error "Output argument is mandatory."
fi

readonly OUTPUT


# Set argument defaults
# ---------------------

# Verbosity options.
: "${VERBOSE:=no}"
: "${QUIET:=no}"
: "${SILENT:=no}"

# We should be able to make an image for other architectures, but the
# default should be this machine's. Use this variable for that.
: "${ARCH:=$(uname -m)}"
: "${ARCH:=unknown}"

# Format defaults are based on architecture.
case "$ARCH" in
    arm*|aarch64)    : "${FORMAT:=fit}" ;;
    x86*|i386|amd64) : "${FORMAT:=zimage}" ;;
    *) error "Architecture '$ARCH' is not supported." ;;
esac

# AFAIK, depthcharge doesn't care about the arch set in the FIT image,
# We can't set "fit|x86|arm" and "fit|arm|x86" cases with this, but they
# are satisfiable with "fit|arm|arm". The zimage format doesn't call
# mkimage so all its cases can be set with --arch x86|arm.
case "$ARCH" in
    arm64|aarch64)  MKIMAGE_ARCH=arm64;     VBOOT_ARCH=aarch64 ;;
    arm*)           MKIMAGE_ARCH=arm;       VBOOT_ARCH=arm ;;
    amd64|x86_64)   MKIMAGE_ARCH=x86_64;    VBOOT_ARCH=amd64 ;;
    x86|i386)       MKIMAGE_ARCH=x86;       VBOOT_ARCH=x86 ;;
    *) error "Architecture '$arch' is not supported" ;;
esac

# If --compress option isn't given, COMPRESS wouldn't be set, but it
# should be set to none in that case.
: "${COMPRESS:=none}"

# Default description can be empty, but needs to be set (sh -o nounset).
: "${DESCRIPTION:=unavailable}"

# If kernel.args is empty, vbutil_kernel returns an error. We can
# use "--" instead of putting a newline or a space into the cmdline.
: "${CMDLINE:=--}"

# Prepend kern_guid=%U by default
: "${ADD_KERN_GUID:=yes}"

# These are distro-specific paths for necessary files.
: "${VBOOT_DEVKEYS:=/usr/share/vboot/devkeys}"
: "${VBOOT_KEYBLOCK:=${VBOOT_DEVKEYS}/kernel.keyblock}"
: "${VBOOT_SIGNPRIVATE:=${VBOOT_DEVKEYS}/kernel_data_key.vbprivk}"

readonly VERBOSE QUIET SILENT
readonly ARCH FORMAT MKIMAGE_ARCH VBOOT_ARCH
readonly COMPRESS DESCRIPTION CMDLINE MAX_SIZE
readonly VBOOT_DEVKEYS VBOOT_KEYBLOCK VBOOT_SIGNPRIVATE

# Check invalid option combinations.
if [ "$FORMAT" = "zimage" ]; then
    if [ "$COMPRESS" != "none" ]; then
        usage_error "--compress is incompatible with zimage format."
    elif [ "$DESCRIPTION" != "unavailable" ]; then
        usage_error "--description is incompatible with zimage format."
    elif [ -n "${DTBS:-}" ]; then
        error "Device tree files not supported with zimage format."
    elif [ -n "${INITRAMFS:-}" ]; then
        error "Initramfs image not supported with zimage format."
    fi
fi


# Prepare vmlinuz
# ---------------

# Decompress kernel if packaged as gzip compressed.
if { command -v gzip && gzip -t "$VMLINUZ"; } >/dev/null 2>&1; then
    temp="$(temp_file vmlinuz-gunzip)"
    info "Kernel is gzip compressed, decompressing."
    gzip -d <"$VMLINUZ" >"$temp"
    VMLINUZ="$temp"
    unset temp
fi

# Compress kernel as appropriate.
case "${COMPRESS:-none}" in
    lz4)
        info "Compressing kernel with lz4."
        temp="$(temp_file vmlinuz.lz4)"
        lz4 -z -9 <"$VMLINUZ" >"$temp"
        VMLINUZ="$temp"
        unset temp
        ;;
    lzma)
        info "Compressing kernel with lzma."
        temp="$(temp_file vmlinuz.lzma)"
        lzma -z <"$VMLINUZ" >"$temp"
        VMLINUZ="$temp"
        unset temp
        ;;
    none)
        : # No need to do anything.
        ;;
    *)
        error "Compression type '${COMPRESS:-}' is not supported." \
                "Valid values are: none, lz4, lzma."
        ;;
esac

readonly VMLINUZ


# Prepare additional files
# ------------------------

# Normalize CMDLINE to a single line.
cmdline="$(
    IFS="${NEWLINE}${TAB}"
    set -- ${CMDLINE:-}
    IFS="$ORIG_IFS"
    printf "%s " "$@"
)"
cmdline="${cmdline% }"

# The firmware replaces any '%U' in the kernel cmdline with the PARTUUID
# of the partition it booted from. ChromeOS uses kern_guid=%U in their
# cmdline and it's useful information, so prepend it to cmdline.
if [ "$ADD_KERN_GUID" = "yes" ]; then
    cmdline="kern_guid=%U${cmdline:+ }${cmdline:-}"
fi

# vbutil_kernel --config argument and wants cmdline as a file.
temp="$(temp_file kernel.args)"
printf "%s" "$cmdline" >"$temp"
VBOOT_CMDLINE="$temp"
unset temp cmdline

# vbutil_kernel --bootloader argument wants a bootstub binary, but it's
# contents don't matter on arm systems.
if [ -z "${VBOOT_BOOTSTUB:-}" ]; then
    case "$VBOOT_ARCH" in
        arm*|aarch64)
            info "Using dummy file for bootloader."
            temp="$(temp_file bootstub)"
            dd if=/dev/zero of="$temp" count=1 bs=512 status=none
            VBOOT_BOOTSTUB="$temp"
            unset temp
            ;;
        x86|amd64|*)
            error "Architecture '$VBOOT_ARCH' needs a bootstub binary."
            ;;
    esac
fi

readonly VBOOT_CMDLINE VBOOT_BOOTSTUB


# Make FIT image
# --------------

temp="$(temp_file depthcharge.itb)"
make_fit() (
    set --

    if [ -n "${DTBS:-}" ]; then
        IFS="${NEWLINE}${TAB}"
        for dtb in $DTBS; do
            set -- "$@" "-b" "$dtb"
        done
        IFS="$ORIG_IFS"
    fi

    if [ -n "${INITRAMFS:-}" ]; then
        set -- "-i" "$INITRAMFS" "$@"
    fi

    mkimage \
        -f auto \
        -A "$MKIMAGE_ARCH" \
        -O linux \
        -C "$COMPRESS" \
        -n "$DESCRIPTION" \
        -d "$VMLINUZ" \
        "$@" \
        "$temp"
)

if [ "$FORMAT" = "fit" ]; then
    info "Running mkimage:"
    if [ "$VERBOSE" = "yes" ]; then
        make_fit >&2
    else
        make_fit >/dev/null
    fi || error "Could not pack inputs into a FIT image."

    FIT_IMAGE="$temp"
fi

unset make_fit
unset temp

readonly FIT_IMAGE


# Make depthcharge image
# ----------------------

if [ "$FORMAT" = "fit" ]; then
    info "Using fit image as vboot kernel."
    VBOOT_VMLINUZ="$FIT_IMAGE"
elif [ "$FORMAT" = "zimage" ]; then
    info "Using vmlinuz file as vboot kernel."
    VBOOT_VMLINUZ="$VMLINUZ"
fi
readonly VBOOT_VMLINUZ

temp="$(temp_file depthcharge.img)"
pack_depthcharge() {
    futility vbutil_kernel \
        --version 1 \
        --arch "$VBOOT_ARCH" \
        --vmlinuz "$VBOOT_VMLINUZ" \
        --config "$VBOOT_CMDLINE" \
        --bootloader "$VBOOT_BOOTSTUB" \
        --keyblock "$VBOOT_KEYBLOCK" \
        --signprivate "$VBOOT_SIGNPRIVATE" \
        --pack "$temp"
}

info "Running vbutil_kernel (pack):"
if [ "$VERBOSE" = "yes" ]; then
    pack_depthcharge >&2
else
    pack_depthcharge >/dev/null
fi || error "Could not pack inputs into a depthcharge image."

DEPTHCHARGE_IMAGE="$temp"
unset temp

readonly DEPTHCHARGE_IMAGE


# Output depthcharge image
# ------------------------

info "Copying image to output '$OUTPUT'."
cp -f "$DEPTHCHARGE_IMAGE" "$OUTPUT" \
    || error "Couldn't copy to output."
